Sk.builtinFiles={"files": {"src/lib/webgl/primitives.js": "// most of this file is from 'tdl'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n\n\n    /**\n     * AttribBuffer manages a TypedArray as an array of vectors.\n     *\n     * @param {number} numComponents Number of components per\n     *     vector.\n     * @param {number|!Array.<number>} numElements Number of vectors or the data.\n     * @param {string} opt_type The type of the TypedArray to\n     *     create. Default = 'Float32Array'.\n     * @param {!Array.<number>} opt_data The data for the array.\n     */\n    var AttribBuffer = function(\n            numComponents, numElements, opt_type) {\n        opt_type = opt_type || 'Float32Array';\n        var type = window[opt_type];\n        if (numElements.length) {\n            this.buffer = new type(numElements);\n            numElements = this.buffer.length / numComponents;\n            this.cursor = numElements;\n        } else {\n            this.buffer = new type(numComponents * numElements);\n            this.cursor = 0;\n        }\n        this.numComponents = numComponents;\n        this.numElements = numElements;\n        this.type = opt_type;\n    };\n\n    AttribBuffer.prototype.stride = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.offset = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.getElement = function(index) {\n        var offset = index * this.numComponents;\n        var value = [];\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            value.push(this.buffer[offset + ii]);\n        }\n        return value;\n    };\n\n    AttribBuffer.prototype.setElement = function(index, value) {\n        var offset = index * this.numComponents;\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            this.buffer[offset + ii] = value[ii];\n        }\n    };\n\n    AttribBuffer.prototype.clone = function() {\n        var copy = new AttribBuffer(\n                this.numComponents, this.numElements, this.type);\n        copy.pushArray(this);\n        return copy;\n    }\n\n    AttribBuffer.prototype.push = function(value) {\n        this.setElement(this.cursor++, value);\n    };\n\n    AttribBuffer.prototype.pushArray = function(array) {\n        //  this.buffer.set(array, this.cursor * this.numComponents);\n        //  this.cursor += array.numElements;\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            this.push(array.getElement(ii));\n        }\n    };\n\n    AttribBuffer.prototype.pushArrayWithOffset =\n    function(array, offset) {\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            var elem = array.getElement(ii);\n            for (var jj = 0; jj < offset.length; ++jj) {\n                elem[jj] += offset[jj];\n            }\n            this.push(elem);\n        }\n    };\n\n    /**\n    * Computes the extents\n    * @param {!AttribBuffer} positions The positions\n    * @return {!{min: !tdl.math.Vector3, max:!tdl.math.Vector3}}\n    *     The min and max extents.\n    */\n    AttribBuffer.prototype.computeExtents = function() {\n        var numElements = this.numElements;\n        var numComponents = this.numComponents;\n        var minExtent = this.getElement(0);\n        var maxExtent = this.getElement(0);\n        for (var ii = 1; ii < numElements; ++ii) {\n            var element = this.getElement(ii);\n            for (var jj = 0; jj < numComponents; ++jj) {\n                minExtent[jj] = Math.min(minExtent[jj], element[jj]);\n                maxExtent[jj] = Math.max(maxExtent[jj], element[jj]);\n            }\n        }\n        return {min: minExtent, max: maxExtent};\n    };\n\n\n    /**\n     * Creates the vertices and indices for a cube. The\n     * cube will be created around the origin. (-size / 2, size / 2)\n     *\n     * @param {number} size Width, height and depth of the cube.\n     * @return {!Object.<string, !tdl.primitives.AttribBuffer>} The\n     *         created plane vertices.\n     */\n    mod.createCube = new Sk.builtin.func(function(size)\n            {\n                var CUBE_FACE_INDICES_ = [\n                    [3, 7, 5, 1],\n                    [0, 4, 6, 2],\n                    [6, 7, 3, 2],\n                    [0, 1, 5, 4],\n                    [5, 7, 6, 4],\n                    [2, 3, 1, 0]\n                ];\n\n                var k = size / 2;\n\n                var cornerVertices = [\n                        [-k, -k, -k],\n                        [+k, -k, -k],\n                        [-k, +k, -k],\n                        [+k, +k, -k],\n                        [-k, -k, +k],\n                        [+k, -k, +k],\n                        [-k, +k, +k],\n                        [+k, +k, +k]\n                    ];\n\n                var faceNormals = [\n                        [+1, +0, +0],\n                        [-1, +0, +0],\n                        [+0, +1, +0],\n                        [+0, -1, +0],\n                        [+0, +0, +1],\n                        [+0, +0, -1]\n                    ];\n\n                var uvCoords = [\n                        [0, 0],\n                        [1, 0],\n                        [1, 1],\n                        [0, 1]\n                    ];\n\n                var numVertices = 6 * 4;\n                var positions = new AttribBuffer(3, numVertices);\n                var normals = new AttribBuffer(3, numVertices);\n                var texCoords = new AttribBuffer(2, numVertices);\n                var indices = new AttribBuffer(3, 6 * 2, 'Uint16Array');\n\n                for (var f = 0; f < 6; ++f) {\n                    var faceIndices = CUBE_FACE_INDICES_[f];\n                    for (var v = 0; v < 4; ++v) {\n                        var position = cornerVertices[faceIndices[v]];\n                        var normal = faceNormals[f];\n                        var uv = uvCoords[v];\n\n                        // Each face needs all four vertices because the normals and texture\n                        // coordinates are not all the same.\n                        positions.push(position);\n                        normals.push(normal);\n                        texCoords.push(uv);\n\n                    }\n                    // Two triangles make a square face.\n                    var offset = 4 * f;\n                    indices.push([offset + 0, offset + 1, offset + 2]);\n                    indices.push([offset + 0, offset + 2, offset + 3]);\n                }\n\n                return {\n                        position: positions,\n                        normal: normals,\n                        texCoord: texCoords,\n                        indices: indices\n                };\n            });\n\n    return mod;\n};\n", "src/lib/goog/ui/__init__.js": "var $builtinmodule = function(name)\n{\n    goog.require('goog.ui.Component');\n\n    var mod = {};\n\n    mod.Component = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, opt_domHelper)\n                    {\n                        self.v = new goog.ui.Component(Sk.ffi.unwrapo(opt_domHelper));\n                    });\n\n                $loc.render = new Sk.builtin.func(function(self, opt_parentElement)\n                    {\n                        self.v.render(Sk.ffi.unwrapo(opt_parentElement));\n                    });\n            },\n            'Component', []);\n            // todo; derives from EventTarget\n\n    return mod;\n};\n", "src/lib/webgl/models.js": "// most of this file is from/based on 'tdl'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var Buffer = function(array, opt_target) {\n        var target = opt_target || gl.ARRAY_BUFFER;\n        var buf = gl.createBuffer();\n        this.target = target;\n        this.buf = buf;\n        this.set(array);\n        this.numComponents_ = array.numComponents;\n        this.numElements_ = array.numElements;\n        this.totalComponents_ = this.numComponents_ * this.numElements_;\n        if (array.buffer instanceof Float32Array) {\n            this.type_ = gl.FLOAT;\n        } else if (array.buffer instanceof Uint8Array) {\n            this.type_ = gl.UNSIGNED_BYTE;\n        } else if (array.buffer instanceof Int8Array) {\n            this.type_ = gl._BYTE;\n        } else if (array.buffer instanceof Uint16Array) {\n            this.type_ = gl.UNSIGNED_SHORT;\n        } else if (array.buffer instanceof Int16Array) {\n            this.type_ = gl.SHORT;\n        } else {\n            throw(\"unhandled type:\" + (typeof array.buffer));\n        }\n    };\n\n    Buffer.prototype.set = function(array) {\n        gl.bindBuffer(this.target, this.buf);\n        gl.bufferData(this.target, array.buffer, gl.STATIC_DRAW);\n    }\n\n    Buffer.prototype.type = function() {\n        return this.type_;\n    };\n\n    Buffer.prototype.numComponents = function() {\n        return this.numComponents_;\n    };\n\n    Buffer.prototype.numElements = function() {\n        return this.numElements_;\n    };\n\n    Buffer.prototype.totalComponents = function() {\n        return this.totalComponents_;\n    };\n\n    Buffer.prototype.buffer = function() {\n        return this.buf;\n    };\n\n    Buffer.prototype.stride = function() {\n        return 0;\n    };\n\n    Buffer.prototype.offset = function() {\n        return 0;\n    };\n\n\n\n    mod.Model = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, shader, arrays, textures)\n                    {\n                        self.buffers = {};\n                        var setBuffer = function(name, array)\n                        {\n                            var target = (name == 'indices') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n                            b = self.buffers[name];\n                            if (!b)\n                                b = new Buffer(array, target);\n                            else\n                                b.set(array);\n                            self.buffers[name] = b;\n                        };\n                        for (name in arrays)\n                            setBuffer(name, arrays[name]);\n\n                        var textureUnits = {};\n                        var unit = 0;\n                        for (var texture in textures)\n                        {\n                            textureUnits[texture] = unit++;\n                        }\n\n                        self.mode = gl.TRIANGLES;\n                        self.textures = textures.v;\n                        self.textureUnits = textureUnits;\n                        self.shader = shader;\n                    });\n\n                /**\n                * Sets up the shared parts of drawing this model. Uses the\n                * program, binds the buffers, sets the textures.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.drawPrep = new Sk.builtin.func(function(self, uniforms)\n                    {\n                        var shader = self.shader;\n                        var buffers = self.buffers;\n                        var textures = self.textures;\n\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n\n                        Sk.misceval.callsim(shader.use, shader);\n\n                        for (var buffer in buffers) {\n                            var b = buffers[buffer];\n                            if (buffer == 'indices') {\n                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.buffer());\n                            } else {\n                                var attrib = shader.attrib[buffer];\n                                if (attrib) {\n                                    attrib(b);\n                                }\n                            }\n                        }\n\n                        for (var texture in textures) {\n                            var unit = self.textureUnits[texture];\n                            shader.setUniform$impl(shader, textuer, unit);\n                            textures[texture].bindToUnit(unit);\n                        }\n\n                        for (var uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n                    });\n\n                /**\n                * Draws this model.\n                *\n                * After calling tdl.models.Model.drawPrep you can call this\n                * function multiple times to draw this model.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.draw = new Sk.builtin.func(function(self, uniforms, opt_textures)\n                    {\n                        var shader = self.shader;\n                        uniforms = Sk.ffi.remapToJs(uniforms);\n                        for (uniform in uniforms) {\n                            shader.setUniform$impl(shader, uniform, uniforms[uniform]);\n                        }\n\n                        if (opt_textures) {\n                            for (var texture in opt_textures) {\n                                var unit = self.textureUnits[texture];\n                                shader.setUniform$impl(shader, texture, unit);\n                                opt_textures[texture].bindToUnit(unit);\n                            }\n                        }\n\n                        var buffers = self.buffers;\n                        gl.drawElements(self.mode, buffers.indices.totalComponents(), gl.UNSIGNED_SHORT, 0);\n                    });\n            },\n            'Model', []);\n\n    return mod;\n};\n", "src/lib/turtle/__init__.js": "//\n//\n// Turtle Graphics Module for Skulpt\n//\n// Brad Miller\n//\n//\n//\n//\n// ----------------------------------------------------------------------\n// The skulpt module wraps an extended version of the TurtleGraphics\n// module written by Tom Verhoeff, although I've pretty much modified it\n// beyond all recognition, so any problems with it are likely mine and\n// not Tom's\n// http://www.win.tue.nl/~wstomv/edu/javascript/tg-commands.html\n// Author: Tom Verhoeff (Eindhoven University of Techology, Netherlands)\n// Contact information: <T.Verhoeff@tue.nl>\n// License: GPL version 3\n\n\n// In the first part of the file I have extended/implemented a turtle graphics \n// module natively in Javascript.  In the second half of the file there is a \n// skulpt wrapper around the first.\n//\nvar TurtleGraphics; // the single identifier needed in the global scope\n\nif ( ! TurtleGraphics ) {\n  TurtleGraphics = { };\n}\n\n// Define private constants, variables, and functions via a closure, and\n// export public entities to global variable TurtleGraphics.\n(function () {\n\n    // Define private constants\n\n    // A vector in 3D space is stored as a 3-element array.\n    // The following constants are to index a vector.\n    var /* const */ x = 0;\n    var /* const */ y = 1;\n    var /* const */ z = 2;\n\n    var /* const */ Degree = Math.PI / 180.0; // conversion factor for degrees to radians\n\n    // Define private variables\n\n    var defaults = [ { canvasID: 'TGspace', unit: 30, degrees: true } ]; // organized as stack\n\n    // Define private functions\n\n    function cloneObject(source) {\n\tfor (i in source) {\n\t    if (typeof source[i] == 'object') {\n\t\tthis[i] = new cloneObject(source[i]);\n\t    }\n\t    else {\n\t\tthis[i] = source[i];\n\t    }\n\t}\n    }\n\n    function top(a) {\n\t// Return what is on top of stack a\n\t// Requires: a is a non-empty array\n\t// Ensures: result = last (topmost) element\n\treturn a[a.length - 1];\n    }\n\n    function linear(a, u, b, v) {\n\t// Return linear combination of u and v\n\t// Requires: u, v are vectors, a is a number\n\t// Ensures: result = a * u + b * v\n\tvar result = [ ];\n\tfor (var c = x; c <= z; ++c) {\n\t    result[c] = a * u[c] + b * v[c];\n\t}\n\treturn result;\n    }\n\n    function cross(u, v) {\n\t// Return cross product of u and v\n\t// Requires: u, v are vectors\n\t// Ensures: result = cross product of u and v\n\tvar result = [ ];\n\tfor (var c = x; c <= z; ++c) {\n\t    result[c] = u[(c+1)%3] * v[(c+2)%3] - u[(c+2)%3] * v[(c+1)%3];\n\t}\n\treturn result;\n    }\n\n    function rotateNormal(u, v, w, alpha) {\n\t// Return rotation of u in direction of v about w over alpha\n\t// Requires: u, v, w are vectors; alpha is angle in radians\n\t//   u, v, w are orthonormal\n\t// Ensures: result = u rotated in direction of v about w over alpha\n\treturn linear(Math.cos(alpha), u, Math.sin(alpha), v);\n    }\n\n    function normalize(u) {\n\tvar res = []\n\tvar n = Math.sqrt(u[x]*u[x] + u[y]*u[y]);\n\tres[x] = u[x]/n;\n\tres[y] = u[y]/n;\n\tres[z] = 0.0;\n\treturn res;\n    }\n\n    function vec2angle(heading) {\n        // workaround for values getting set to +/i xxx e -16 fooling the +/- checks below\n\tif (Math.abs(heading[y]) < 0.00001) heading[y] = 0.0;\n\tif (Math.abs(heading[x]) < 0.00001) heading[x] = 0.0;\n\tvar rads = Math.atan(Math.abs(heading[y]) / Math.abs(heading[x]));\n\tvar deg = rads * 180.0 / Math.PI;\n\tif (heading[x] < 0 && heading[y] < 0) deg = 180 - deg;\n\telse if (heading[x] < 0 && heading[y] >= 0) deg = 180.0 + deg;\n        else if (heading[x] >= 0 && heading[y] > 0) deg = 360 - deg;\n\treturn deg;\n    }\n\n    function angle2vec(phi) {\n\tvar res = [0.0,0.0,0.0];\n\tphi = phi * Degree;\n\tres[x] = Math.cos(phi);\n\tres[y] = Math.sin(phi)*-1.0;  // compensate for upside down y coordinates on canvas\n\treturn normalize(res);\n    }\n\n    // Define functions to be made public\n\n    // Constructor for Turtle objects\n    function Turtle() {\n\t// Construct new turtle.\n\t// Optional argument is passed to Init()\n\t// Define public properties\n\tthis.log = '';\n\tthis.logging = false;\n\t\n\t// Initialize (define and initialize remaining public properties\n\tif ( arguments.length >= 1 ) {\n\t    this.Init(arguments[0]);\n\t}\n\telse {\n\t    this.Init();\n\t}\n    }\n\n    // Define shared properties of all Turtle objects\n    Turtle.prototype.Degree = Degree;\n\n\n    // Define public methods of Turtle objects\n\n    Turtle.prototype.Home = function () {\n\t// Put turtle in initial state\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'Home();\\n';\n\t    }\n\t    position = home;\n\t    context.moveTo(home[x],home[y]);\n\t    heading = [1.0, 0.0, 0.0]; // to the right; in turtle space x+ direction\n\t    normal = [0.0, 0.0, 1.0]; // in z+ direction\n\t}\n    };\n\n    Turtle.prototype.Init = function () {\n\t// Initialize the turtle.\n\t// Optional argument is object with some initial values:\n\t//   options.origin = string of the form /(t|m|b)(l|c|r)/\n\t//     t = top, m = middle, b = bottom, l = left, c = center, r = right\n\t//   options.unit = unit length in pixels\n\t//   options.canvasID = id of canvas element for drawing\n\tvar options = { };\n\tif ( arguments.length >= 1 ) {\n\t    options = arguments[0];\n\t}\n\t//writeObject('option = ', option);\n\tthis.unit = top(defaults).unit; // position scaling to define the unit length\n\tif ( options.unit ) {\n\t    this.unit = options.unit;\n\t}\n\tthis.canvasID = top(defaults).canvasID;\n\tif ( options.canvasID ) {\n\t    this.canvasID = options.canvasID;\n\t}\n\tthis.context = document.getElementById(this.canvasID).getContext('2d');\n\t//writeObject(this.context.canvas, 'canvas'); // test\n\t//writeObject(this.context, 'context'); // test\n\twith ( this.context ) {\n\t    var x0 = canvas.width / 2;\n\t    var y0 = canvas.height / 2;\n\t    if ( options.origin ) {\n\t\tfor (var i = 0; i != options.origin.length; ++i) {\n\t\t    switch ( options.origin.charAt(i) ) {\n\t\t    case 't': x0 = 0.0; break;\n\t\t    case 'm': x0 = canvas.width / 2; break;\n\t\t    case 'b': x0 = canvas.width; break;\n\t\t    case 'l': y0 = 0.0; break;\n\t\t    case 'c': y0 = canvas.height / 2; break;\n\t\t    case 'r': y0 = canvas.height; break;\n\t\t    }\n\t\t}\n\t    }\n\t    this.home = [x0, y0, 0.0]; // its origin\n\t    this.position = [ ]; // set by Home()\n\t    this.heading = [ ]; // set by Home()\n\t    this.normal = [ ]; // set by Home()\n\t    this.pen = true; // active\n\t    this.penStyle = 'black';\n\t    this.penWidth = 2;\n\t    this.fillStyle = 'white';\n\t    this.Home();\n\t    this.logging = true;\n\t    //writeObject(this, 'this');\n\t}\n    }\n\n    Turtle.prototype.Clean = function () {\n\t// Clean the canvas\n\t// Optional second argument is color\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tvar arg = '';\n\t\tif ( arguments.length >= 1 ) {\n\t\t    arg = '\\'' + arguments[0] + '\\'';\n\t\t}\n\t\tlog += 'Clean(' + arg + ');\\n';\n\t    }\n\t    if ( arguments.length >= 1 ) {\n\t\tClear(canvasID, arguments[0]);\n\t    }\n\t    else {\n\t\tClear(canvasID);\n\t    }\n\t    Init();\n\t}\n    }\n\n    Turtle.prototype.PenActive = function (b) {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'PenActive(' + b + ');\\n';\n\t    }\n\t    pen = b;\n\t}\n    }\n\n    Turtle.prototype.PenDown = function () {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'PenDown();\\n';\n\t    }\n\t    pen = true;\n\t}\n    }\n\n    Turtle.prototype.PenUp = function () {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'PenUp();\\n';\n\t    }\n\t    pen = false;\n\t}\n    }\n\n    Turtle.prototype.GetPen = function () {\n\treturn this.pen;\n    }\n\n    Turtle.prototype.SetPenWidth = function (w) {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'SetPenWidth(' + w + ');\\n';\n\t    }\n\t    penWidth = w;\n\t}\n    }\n\n    Turtle.prototype.SetPenStyle = function (c) {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'SetPenStyle(\\'' + c + '\\');\\n';\n\t    }\n\t    penStyle = c;\n\t}\n    }\n\n    Turtle.prototype.SetFillStyle = function (c) {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'SetPenStyle(\\'' + c + '\\');\\n';\n\t    }\n\t    fillStyle = c;\n\t    context.fillStyle = c;\n\t}\n    }\n\n    Turtle.prototype.BeginFill = function () {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'BeginFill();\\n';\n\t    }\n\t    context.beginPath();\n\t}\n    }\n\n    Turtle.prototype.EndFill = function () {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'EndFill();\\n';\n\t    }\n\t    context.closePath();\n\t    context.fill();\n\t}\n    }\n\n\n    Turtle.prototype.Move = function (d) {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'Move(' + d + ');\\n';\n\t    }\n\t    var newposition = linear(1, position, d * unit, heading);\n\t    if ( pen ) {\n\t\twith ( context ) {\n\t\t    lineCap = 'round';\n\t\t    lineJoin = 'round';\n\t\t    lineWidth = penWidth;\n\t\t    strokeStyle = penStyle;\n\t\t    lineTo(newposition[x], newposition[y]);\n\t\t    stroke();\n\t\t}\n\t    }\n\t    position = newposition;\n\t}\n    }\n\n    Turtle.prototype.Goto = function(nx,ny) {\n\tvar newposition = [nx,ny,0];\n\twith (this) {\n\t    if (pen) {\n\t\twith ( context ) {\n\t\t    lineCap = 'round';\n\t\t    lineJoin = 'round';\n\t\t    lineWidth = penWidth;\n\t\t    strokeStyle = penStyle;\n\t\t    lineTo(newposition[x], newposition[y]);\n\t\t    stroke();\n\t\t}\n\t    } else {\n\t\tcontext.moveTo(newposition[x], newposition[y]);\n\t    }\n\t    position = newposition;\n\t    \n\t}\n    }\n\n    Turtle.prototype.Turn = function (phi) {\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'Turn(' + phi + ');\\n';\n\t    }\n\t    var alpha = phi * Degree;\n\t    var left = cross(normal, heading);\n\t    var newheading = rotateNormal(heading, left, normal, alpha);\n\t    heading = newheading;\n\t}\n    }\n\n    Turtle.prototype.GetHeading = function () {\n\tif (top(defaults)['degrees'])\n\t    return vec2angle(this.heading)\n\telse\n\t    return this.heading\n    }\n\n    Turtle.prototype.GetPosition = function () {\n\treturn this.position;\n    }\n\n    Turtle.prototype.GetX = function () {\n\treturn this.position[x];\n    }\n\n    Turtle.prototype.GetY = function () {\n\treturn this.position[y];\n    }\n\n    Turtle.prototype.SetHeading = function(newhead) {\n\tif ((typeof(newhead)).toLowerCase() === 'number') {\n\t    console.log(\"newhead = \" + newhead);\n\t    this.heading = angle2vec(newhead);\n\t    console.log(\"vector of newhead = \" + this.heading);\n\t} else {\n\t    this.heading = newhead;\n\t}\n    }\n\n    Turtle.prototype.Towards = function(to) {\n\t// set heading vector to point towards another point.\n\tvar res = [];\n\tres[x] = to[x] - this.position[x];\n\tres[y] = to[y] - this.position[y];\n\tres[z] = to[z] - this.position[z];\n\tres = normalize(res);\n\tconsole.log(\"vector towards \" + to + \" is \" + res);\n\tif (top(defaults)['degrees'])\n\t    return vec2angle(res);\n\telse\n\t    return res;\n    }\n\n    Turtle.prototype.Distance = function(to) {\n\tvar xdiff = to[x] - this.position[x];\n\tvar ydiff = to[y] - this.position[y];\n\tvar zdiff = to[z] - this.position[z];\n\treturn Math.sqrt(xdiff*xdiff + ydiff*ydiff + zdiff*zdiff);\n    }\n\n    Turtle.prototype.Dot = function() {\n\tvar size = 2;\n\tif (arguments.length >= 1) size = arguments[0];\n\twith (this) {\n\t    with ( context ) {\n\t\tif (arguments.length >= 2) {\n\t\t    fillStyle = arguments[1];\n\t\t}\n\t\tfillRect(position[x]-size/2, position[y]-size/2, size, size);\n\t    }\n\t}\n\t    \n    }\n\n    Turtle.prototype.Write = function(theText, move, align, font) {\n\tthis.context.fillText(theText,this.position[x], this.position[y]);\n    }\n\n    Turtle.prototype.DrawTurtle = function (c) {\n\t// Draw turle (as triangle with fin tail; right wing filled with c)\n\twith ( this ) {\n\t    if ( logging ) {\n\t\tlog += 'DrawTurtle(\\'' + c + '\\');\\n';\n\t    }\n\t    turtle = this;\n\t    var left = cross(normal, heading);\n\t    var alpha = 30 * Degree; // half nose angle\n\t    var ca = Math.cos(alpha);\n\t    var sa = Math.sin(alpha);\n\t    var h = unit; // hypothenuse\n\t    var a = 2/3 * h * ca; // distance from center to tip of nose\n\t    \n\t    var nose = linear(1, position, a, heading);\n\t    var back = linear(1, nose, -h * ca, heading);\n\t    var port = linear(1, back,  h * sa, left); // port-side tip\n\t    var star = linear(1, back, -h * sa, left); // starboard-side tip\n\t    var fin  = linear(1, back,  h * sa, normal); // fin tip\n\n\t    function drawWings() {\n\t\twith ( turtle ) with ( context ) {\n\t\t    // starboard wing\n\t\t    beginPath();\n\t\t    moveTo(nose[y], nose[x]);\n\t\t    lineTo(back[y], back[x]);\n\t\t    lineTo(star[y], star[x]);\n\t\t    closePath();\n\t\t    fillStyle = c;\n\t\t    fill();\n\t\t    \n\t\t    // port wing\n\t\t    beginPath();\n\t\t    moveTo(nose[y], nose[x]);\n\t\t    lineTo(back[y], back[x]);\n\t\t    lineTo(port[y], port[x]);\n\t\t    closePath();\n\t\t    fillStyle = 'white';\n\t\t    fill();\n\t\t    \n\t\t    // wing decorations\n\t\t    if ( normal[z] >= 0 ) { // eyes on top\n\t\t\tsave();\n\t\t\tlineWidth = 2;\n\t\t\tbeginPath ();\n\t\t\tmoveTo(position[y] + a/2 * heading[y] + (star[y] - back[y]) / 7,\n\t\t\t       position[x] + a/2 * heading[x] + (star[x] - back[x]) / 7);\n\t\t\tlineTo(position[y] + a/2 * heading[y] + (star[y] - back[y]) / 7,\n\t\t\t       position[x] + a/2 * heading[x] + (star[x] - back[x]) / 7);\n\t\t\tstrokeStyle = 'white';\n\t\t\tstroke()\n\t\t\tbeginPath ();\n\t\t\tmoveTo(position[y] + a/2 * heading[y] + (port[y] - back[y]) / 7,\n\t\t\t       position[x] + a/2 * heading[x] + (port[x] - back[x]) / 7);\n\t\t\tlineTo(position[y] + a/2 * heading[y] + (port[y] - back[y]) / 7,\n\t\t\t       position[x] + a/2 * heading[x] + (port[x] - back[x]) / 7);\n\t\t\tstrokeStyle = c;\n\t\t\tstroke()\n\t\t\trestore();\n\t\t    }\n\t\t    else { // arrow head on the bottom\n\t\t\t// fin is down, draw cross hair\n\t\t\tbeginPath();\n\t\t\tmoveTo(position[y], position[x]);\n\t\t\t//lineTo(position[y] + unit/6 * left[y],\n\t\t\t//  position[x] + unit/6 * left[x]);\n\t\t\tlineTo(position[y] + (port[y] - nose[y]) / 5,\n\t\t\t       position[x] + (port[x] - nose[x]) / 5);\n\t\t\tstrokeStyle = c;\n\t\t\tstroke();\n\t\t\tbeginPath();\n\t\t\tmoveTo(position[y], position[x]);\n\t\t\t//lineTo(position[y] - unit/6 * left[y],\n\t\t\t//  position[x] - unit/6 * left[x]);\n\t\t\tlineTo(position[y] + (star[y] - nose[y]) / 5,\n\t\t\t       position[x] + (star[x] - nose[x]) / 5);\n\t\t\tstrokeStyle = 'white';\n\t\t\tstroke();\n\t\t    }\n\t\t    \n\t\t    // startboard wing's edge\n\t\t    beginPath();\n\t\t    moveTo(nose[y], nose[x]);\n\t\t    lineTo(star[y], star[x]);\n\t\t    lineTo(back[y], back[x]);\n\t\t    strokeStyle = 'white';\n\t\t    stroke();\n\t\t    \n\t\t    // port wing's edge\n\t\t    beginPath();\n\t\t    moveTo(nose[y], nose[x]);\n\t\t    lineTo(port[y], port[x]);\n\t\t    lineTo(back[y], back[x]);\n\t\t    strokeStyle = c;\n\t\t    stroke();\n\t\t}\n\t    }\n\t    \n\t    function drawFinFace(fc) {\n\t\twith ( turtle ) with ( context ) {\n\t\t    beginPath();\n\t\t    moveTo(position[y], position[x]);\n\t\t    lineTo(fin [y], fin [x]);\n\t\t    lineTo(back[y], back[x]);\n\t\t    closePath();\n\t\t    fillStyle = fc;\n\t\t    fill();\n\t\t}\n\t    }\n\t    \n\t    function drawFinEdge(fc) {\n\t\twith ( turtle ) with ( context ) {\n\t\t    beginPath();\n\t\t    moveTo(position[y], position[x]);\n\t\t    lineTo(fin [y], fin [x]);\n\t\t    lineTo(back[y], back[x]);\n\t\t    closePath();\n\t\t    strokeStyle = fc;\n\t\t    stroke();\n\t\t}\n\t    }\n\t    \n\t    function drawFin() {\n\t\twith ( turtle ) with ( context ) {\n\t\t    if ( left[z] >= 0 ) {\n\t\t\tdrawFinFace('white');\n\t\t\tdrawFinEdge(c);\n\t\t    }\n\t\t    else {\n\t\t\tdrawFinEdge('white');\n\t\t\tdrawFinFace(c);\n\t\t    }\n\t\t}\n\t    }\n\t    \n\t    with ( context ) {\n\t\tsave();\n\t\tlineWidth = 1;\n\t\tlineCap = 'round';\n\t\tlineJoin = 'round';\n\t\t\n\t\tif ( normal[z] >= 0 ) {\n\t\t    // fin is up, draw it last\n\t\t    drawWings();\n\t\t    drawFin();\n\t\t}\n\t\telse {\n\t\t    // fin is down, draw it first\n\t\t    drawFin();\n\t\t    drawWings();\n\t\t}\n\t\t\n\t\trestore();\n\t    }\n\t}\n    }\n\n    // Define abbreviated public methods for Turtle objects\n    Turtle.prototype.PA = Turtle.prototype.PenActive;\n    Turtle.prototype.PD = Turtle.prototype.PenDown;\n    Turtle.prototype.PU = Turtle.prototype.PenUp;\n    Turtle.prototype.M = Turtle.prototype.Move;\n    Turtle.prototype.T = Turtle.prototype.Turn;\n    Turtle.prototype.DT = Turtle.prototype.DrawTurtle;\n\n\n    // Define functions to be made public (continued)\n\n    function Clear(sp) {\n\t// Clear canvas with ID sp.\n\t// Optional second argument is color.\n\twith ( document.getElementById(sp).getContext('2d') ) {\n\t    canvas.width = canvas.width; // clear the canvas\n\t    if ( arguments.length >= 2 ) {\n\t\tfillStyle = arguments[1];\n\t\tfillRect(0, 0, canvas.width, canvas.height);\n\t    }\n\t}\n    }\n\n    function SetDefaults(def) {\n\t// Set defaults in def (other defaults are unaffected)\n\tfor (var p in def) {\n\t    top(defaults)[p] = def[p];\n\t}\n    }\n\n    function GetDefaults() {\n\t// Return current defaults\n\treturn top(defaults);\n    }\n\n    function PushDefaults(def) {\n\t// Push new defaults def, making them active\n\t// Requires: def = object with properties canvasID and unit\n\tdefaults.push(new cloneObject(top(defaults))); // first, copy top\n\tSetDefaults(def); // then update with values from parameter\n    }\n\n    function PopDefaults() {\n\t// Pop defaults, making the underlying defaults active again\n\t// Requires: defaults.length > 1\n\tif ( defaults.length > 1 ) {\n\t    defaults.pop();\n\t}\n    }\n\n    function Test() {\n\tvar result = '';\n\tresult += cross([0, 0, 1], [1, 0, 0]) + '\\n';\n\tresult += obj2Str('defaults = ', top(defaults)) + '\\n';\n\tSetDefaults({ canvasID: 'TGexample1' });\n\tresult += obj2Str('defaults = ', top(defaults)) + '\\n';\n\tPushDefaults({ canvasID: 'TGexample2' });\n\tresult += obj2Str('defaults = ', top(defaults)) + '\\n';\n\tPopDefaults();\n\tresult += obj2Str('defaults = ', top(defaults)) + '\\n';\n\treturn result;\n    }\n\n    // Export public functions\n    TurtleGraphics.Turtle = Turtle;\n    TurtleGraphics.Clear = Clear;\n    TurtleGraphics.SetDefaults = SetDefaults;\n    TurtleGraphics.GetDefaults = GetDefaults;\n    TurtleGraphics.PushDefaults = PushDefaults;\n    TurtleGraphics.PopDefaults = PopDefaults;\n    TurtleGraphics.Test = Test;\n\n})();\n\n//\n// Wrapper around the Turtle Module starts here.\n//\n//\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n    // First we create an object, this will end up being the class\n    // class\n    var turtle = function($gbl, $loc) {\n\t$loc.__init__ = new Sk.builtin.func(function(self) {\n\t    TurtleGraphics.SetDefaults({canvasID: Sk.canvas, unit:1, origin: \"mc\"});\n\t    self.theTurtle = new TurtleGraphics.Turtle();\n\t});\n\n//\n// Turtle Motion\n//\n\t//\n\t// Move and Draw\n\t//\n\t$loc.forward = new Sk.builtin.func(function(self, dist) {\n\t    self.theTurtle.Move(dist);\n\t});\n\n\t$loc.fd = $loc.forward;\n\n\t$loc.backward = new Sk.builtin.func(function(self, dist) {\n\t    self.theTurtle.Move(-dist);\n\t});\n\n\t$loc.back = $loc.backward;\n\t$loc.bk = $loc.backward;\n\n\t$loc.right = new Sk.builtin.func(function(self, angle) {\n\t    self.theTurtle.Turn(angle);\n\t});\n\n\t$loc.rt = $loc.right;\n\n\t$loc.left = new Sk.builtin.func(function(self, angle) {\n\t    self.theTurtle.Turn(-angle);\n\t});\n\t\n\t$loc.lt = $loc.left;\n\n\t$loc.goto = new Sk.builtin.func(function(self,nx,ny) {\n\t    self.theTurtle.Goto(nx,ny);\n\t});\n\n\t$loc.setpos = $loc.goto;\n\t$loc.setposition = $loc.goto;\n\n\t$loc.setx = new Sk.builtin.func(function(self,nx) {\n\t    self.theTurtle.Goto(nx,self.theTurtle.GetY());\n\t});\n\n\t$loc.sety = new Sk.builtin.func(function(self,ny) {\n\t    self.theTurtle.Goto(self.theTurtle.GetX(),ny);\n\t});\n\n\t$loc.setheading = new Sk.builtin.func(function(self,newhead) {\n\t    return self.theTurtle.SetHeading(newhead);\n\t});\n\n\t$loc.seth = $loc.setheading;\n\n\t$loc.home = new Sk.builtin.func(function(self) {\n\t    self.theTurtle.Home();\n\t});\n\n\t$loc.dot = new Sk.builtin.func(function(self, /*opt*/ size, color) {\n\t    size = size || 1;\n\t    if (color)\n\t\tcolor = color.v || self.theTurtle.context.fillStyle;\n\t    self.theTurtle.Dot(size,color);\n\t});\n\n\t// todo:  stamp, clearstamp, clearstamps, undo, speed\n\n\t//\n\t// Tell Turtle's state\n\t//\n\t$loc.heading = new Sk.builtin.func(function(self) {\n\t    return self.theTurtle.GetHeading();\n\t});\n\n\t$loc.position = new Sk.builtin.func(function(self) {\n\t    var res = self.theTurtle.GetPosition();\n\t    var x = new Sk.builtin.tuple(res);\n\t    return x;\n\t});\n\n\t$loc.pos = $loc.position;\n\n\t$loc.xcor = new Sk.builtin.func(function(self) {\n\t    var res = self.theTurtle.GetX();\n\t    return res;\n\t});\n\n\t$loc.ycor = new Sk.builtin.func(function(self) {\n\t    var res = self.theTurtle.GetY();\n\t    return res;\n\t});\n\n\t$loc.towards = new Sk.builtin.func(function(self,tx,ty) {\n\t    if ((typeof(tx)).toLowerCase() === 'number')\n\t\ttx = [tx, ty, 0];\n\t    return self.theTurtle.Towards(tx);\n\t});\n\n\t// tx can be either a number or a vector position.\n\t// tx can not be a turtle at this time as multiple turtles have not been implemented yet.\n\t$loc.distance = new Sk.builtin.func(function(self,tx,ty) {\n\t    if ((typeof(tx)).toLowerCase() === 'number')\n\t\ttx = [tx, ty, 0];\n\t    return self.theTurtle.Distance(tx);\n\t});\n\n\t//\n\t// Setting and Measurement\n\t//\n\n\t// todo:  degrees and radians...\n\n//\n// Pen Control\n//\n\n\t//\n\t// Drawing State\n\t//\n\n\t$loc.up = new Sk.builtin.func(function(self) {\n\t    self.theTurtle.PenUp();\n\t});\n\t\n\t$loc.penup = $loc.up;\n\t$loc.pu = $loc.up;\n\n\t$loc.down = new Sk.builtin.func(function(self) {\n\t    self.theTurtle.PenDown();\n\t});\n\n\t$loc.pendown = $loc.down;\n\t$loc.pd = $loc.down;\n\n\t$loc.width = new Sk.builtin.func(function(self,w) {\n\t    self.theTurtle.SetPenWidth(w);\n\t});\n\t\n\t$loc.pensize = $loc.width;\n\n\t$loc.isdown = new Sk.builtin.func(function(self) {\n\t    return self.theTurtle.GetPen();\n\t});\n\n\t// todo:  pen  -- return a dictionary full of pen stuff\n\n\t//\n\t// Color Control\n\t//\n\n\t$loc.fillcolor = new Sk.builtin.func(function(self, color) {\n\t    if (color) {\n\t\tcolor = color.v || self.theTurtle.context.fillStyle;\n\t\tself.theTurtle.SetFillStyle(color);\n\t    } else\n\t\treturn self.theTurtle.fillStyle;\n\t});\n\n\t$loc.color = new Sk.builtin.func(function(self, color) {\n\t    if (color) {\n\t\tcolor = color.v || self.theTurtle.context.fillStyle;\n\t\tself.theTurtle.SetPenStyle(color);\n\t    } else\n\t\treturn self.theTurtle.penStyle;\n\t});\n\n\t$loc.pencolor = $loc.color;\n\n\t//\n\t//  Filling\n\t//\n\n\t$loc.begin_fill = new Sk.builtin.func(function(self) {\n\t    self.theTurtle.BeginFill();\n\t});\n\n\t$loc.end_fill = new Sk.builtin.func(function(self) {\n\t    self.theTurtle.EndFill();\n\t});\n\n\t$loc.fill = new Sk.builtin.func(function(self,fillt) {\n\t    if (fillt)\n\t\tself.theTurtle.BeginFill();\n\t    else\n\t\tself.theTurtle.EndFill();\n\t});\n\n\t//\n\t// More drawing control\n\t//\n\n\t$loc.reset = new Sk.builtin.func(function(self) {\n\t    self.theTurtle.Clean();\n\t});\n\n\t$loc.write = new Sk.builtin.func(function(self,mystr) {\n\t    self.theTurtle.Write(mystr.v);\n\t});\n\n\t// todo clean  -- again multiple turtles\n\t\n    }\n    \n    mod.Turtle = Sk.misceval.buildClass(mod, turtle, 'Turtle', []);\n\n    return mod\n}", "src/lib/webgl/matrix4.js": "// more from 'tdl'\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var temp0v3_ = new Float32Array(3);\n    var temp1v3_ = new Float32Array(3);\n    var temp2v3_ = new Float32Array(3);\n\n    var temp0v4_ = new Float32Array(4);\n    var temp1v4_ = new Float32Array(4);\n    var temp2v4_ = new Float32Array(4);\n\n    var temp0m4_ = new Float32Array(16);\n    var temp1m4_ = new Float32Array(16);\n    var temp2m4_ = new Float32Array(16);\n\n    var normalize = function(dst, a) {\n        var n = 0.0;\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            n += a[i] * a[i];\n        n = Math.sqrt(n);\n        if (n > 0.00001) {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = a[i] / n;\n        } else {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = 0;\n        }\n        return dst;\n    };\n\n    var cross = function(dst, a, b) {\n        dst[0] = a[1] * b[2] - a[2] * b[1];\n        dst[1] = a[2] * b[0] - a[0] * b[2];\n        dst[2] = a[0] * b[1] - a[1] * b[0];\n        return dst;\n    };\n\n    var subVector = function(dst, a, b) {\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            dst[i] = a[i] - b[i];\n        return dst;\n    };\n\n    var dot = function(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    };\n\n    mod.lookAt = new Sk.builtin.func(function(view, eye, target, up)\n            {\n                var t0 = temp0v3_;\n                var t1 = temp1v3_;\n                var t2 = temp2v3_;\n\n                var vz = normalize(t0, subVector(t0, eye.v, target.v));\n                var vx = normalize(t1, cross(t1, up.v, vz));\n                var vy = cross(t2, vz, vx);\n\n                var dst = view.v;\n                dst[ 0] = vx[0];\n                dst[ 1] = vy[0];\n                dst[ 2] = vz[0];\n                dst[ 3] = 0;\n                dst[ 4] = vx[1];\n                dst[ 5] = vy[1];\n                dst[ 6] = vz[1];\n                dst[ 7] = 0;\n                dst[ 8] = vx[2];\n                dst[ 9] = vy[2];\n                dst[10] = vz[2];\n                dst[11] = 0;\n                dst[12] = -dot(vx, eye.v);\n                dst[13] = -dot(vy, eye.v);\n                dst[14] = -dot(vz, eye.v);\n                dst[15] = 1;\n\n                return view;\n            });\n\n    mod.perspective = new Sk.builtin.func(function(proj, angle, aspect, near, far)\n            {\n                var f = Math.tan(Math.PI * 0.5 - 0.5 * (angle * Math.PI / 180));\n                var rangeInv = 1.0 / (near - far);\n\n                var dst = proj.v;\n\n                dst[0]  = f / aspect;\n                dst[1]  = 0;\n                dst[2]  = 0;\n                dst[3]  = 0;\n\n                dst[4]  = 0;\n                dst[5]  = f;\n                dst[6]  = 0;\n                dst[7]  = 0;\n\n                dst[8]  = 0;\n                dst[9]  = 0;\n                dst[10] = (near + far) * rangeInv;\n                dst[11] = -1;\n\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = near * far * rangeInv * 2;\n                dst[15] = 0;\n\n                return proj;\n            });\n\n    // builds, not appending\n    mod.rotationY = new Sk.builtin.func(function(target, angle)\n            {\n                var dst = target.v;\n                var c = Math.cos(angle * Math.PI / 180);\n                var s = Math.sin(angle * Math.PI / 180);\n\n                dst[ 0] = c;\n                dst[ 1] = 0;\n                dst[ 2] = -s;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = s;\n                dst[ 9] = 0;\n                dst[10] = c;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n\n                return target;\n            });\n\n    mod.identity = new Sk.builtin.func(function(target)\n            {\n                var dst = target.v;\n                dst[ 0] = 1;\n                dst[ 1] = 0;\n                dst[ 2] = 0;\n                dst[ 3] = 0;\n                dst[ 4] = 0;\n                dst[ 5] = 1;\n                dst[ 6] = 0;\n                dst[ 7] = 0;\n                dst[ 8] = 0;\n                dst[ 9] = 0;\n                dst[10] = 1;\n                dst[11] = 0;\n                dst[12] = 0;\n                dst[13] = 0;\n                dst[14] = 0;\n                dst[15] = 1;\n                return target;\n            });\n\n    // row major\n    mod.mul = new Sk.builtin.func(function(target, x, y)\n            {\n                var dst = target.v;\n                var a = x.v;\n                var b = y.v;\n                var a00 = a[0];\n                var a01 = a[1];\n                var a02 = a[2];\n                var a03 = a[3];\n                var a10 = a[ 4 + 0];\n                var a11 = a[ 4 + 1];\n                var a12 = a[ 4 + 2];\n                var a13 = a[ 4 + 3];\n                var a20 = a[ 8 + 0];\n                var a21 = a[ 8 + 1];\n                var a22 = a[ 8 + 2];\n                var a23 = a[ 8 + 3];\n                var a30 = a[12 + 0];\n                var a31 = a[12 + 1];\n                var a32 = a[12 + 2];\n                var a33 = a[12 + 3];\n                var b00 = b[0];\n                var b01 = b[1];\n                var b02 = b[2];\n                var b03 = b[3];\n                var b10 = b[ 4 + 0];\n                var b11 = b[ 4 + 1];\n                var b12 = b[ 4 + 2];\n                var b13 = b[ 4 + 3];\n                var b20 = b[ 8 + 0];\n                var b21 = b[ 8 + 1];\n                var b22 = b[ 8 + 2];\n                var b23 = b[ 8 + 3];\n                var b30 = b[12 + 0];\n                var b31 = b[12 + 1];\n                var b32 = b[12 + 2];\n                var b33 = b[12 + 3];\n                dst[ 0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;\n                dst[ 1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;\n                dst[ 2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;\n                dst[ 3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;\n                dst[ 4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;\n                dst[ 5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;\n                dst[ 6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;\n                dst[ 7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;\n                dst[ 8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;\n                dst[ 9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;\n                dst[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;\n                dst[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;\n                dst[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;\n                dst[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;\n                dst[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;\n                dst[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;\n                return target;\n            });\n\n    mod.invert = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                var m00 = m[0 * 4 + 0];\n                var m01 = m[0 * 4 + 1];\n                var m02 = m[0 * 4 + 2];\n                var m03 = m[0 * 4 + 3];\n                var m10 = m[1 * 4 + 0];\n                var m11 = m[1 * 4 + 1];\n                var m12 = m[1 * 4 + 2];\n                var m13 = m[1 * 4 + 3];\n                var m20 = m[2 * 4 + 0];\n                var m21 = m[2 * 4 + 1];\n                var m22 = m[2 * 4 + 2];\n                var m23 = m[2 * 4 + 3];\n                var m30 = m[3 * 4 + 0];\n                var m31 = m[3 * 4 + 1];\n                var m32 = m[3 * 4 + 2];\n                var m33 = m[3 * 4 + 3];\n                var tmp_0  = m22 * m33;\n                var tmp_1  = m32 * m23;\n                var tmp_2  = m12 * m33;\n                var tmp_3  = m32 * m13;\n                var tmp_4  = m12 * m23;\n                var tmp_5  = m22 * m13;\n                var tmp_6  = m02 * m33;\n                var tmp_7  = m32 * m03;\n                var tmp_8  = m02 * m23;\n                var tmp_9  = m22 * m03;\n                var tmp_10 = m02 * m13;\n                var tmp_11 = m12 * m03;\n                var tmp_12 = m20 * m31;\n                var tmp_13 = m30 * m21;\n                var tmp_14 = m10 * m31;\n                var tmp_15 = m30 * m11;\n                var tmp_16 = m10 * m21;\n                var tmp_17 = m20 * m11;\n                var tmp_18 = m00 * m31;\n                var tmp_19 = m30 * m01;\n                var tmp_20 = m00 * m21;\n                var tmp_21 = m20 * m01;\n                var tmp_22 = m00 * m11;\n                var tmp_23 = m10 * m01;\n\n                var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\n                    (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\n                var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\n                    (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\n                var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\n                    (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\n                var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\n                    (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\n\n                var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n\n                dst[ 0] = d * t0;\n                dst[ 1] = d * t1;\n                dst[ 2] = d * t2;\n                dst[ 3] = d * t3;\n                dst[ 4] = d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\n                        (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));\n                dst[ 5] = d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\n                        (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));\n                dst[ 6] = d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\n                        (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));\n                dst[ 7] = d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\n                        (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));\n                dst[ 8] = d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\n                        (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));\n                dst[ 9] = d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\n                        (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));\n                dst[10] = d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\n                        (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));\n                dst[11] = d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\n                        (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));\n                dst[12] = d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\n                        (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));\n                dst[13] = d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\n                        (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));\n                dst[14] = d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\n                        (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));\n                dst[15] = d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\n                        (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));\n                return target;\n            });\n\n    mod.transpose = new Sk.builtin.func(function(target, mat)\n            {\n                var dst = target.v;\n                var m = mat.v;\n                for (var j = 0; j < 4; ++j) {\n                    for (var i = 0; i < 4; ++i)\n                    dst[j * 4 + i] = m[i * 4 + j];\n                }\n                return dst;\n            });\n\n    return mod;\n};\n", "src/lib/goog/dom/__init__.js": "var $builtinmodule = function(name)\n{\n    goog.require('goog.dom');\n\n    var mod = {};\n\n    mod.getElement = new Sk.builtin.func(function(element)\n            {\n                // todo; need to wrap this with something. Element is a\n                // browser builtin type though, not a Closure one.\n            \n                // todo; assuming str right now (rather than\n                // string|Element)\n                return goog.dom.getElement(element.v);\n            });\n\n\n    mod.Component = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, opt_domHelper)\n                    {\n                        self.v = new goog.ui.Component(Sk.ffi.unwrapo(opt_domHelper));\n                    });\n\n                $loc.render = new Sk.builtin.func(function(self, opt_parentElement)\n                    {\n                        self.v.render(Sk.ffi.unwrapo(opt_parentElement));\n                    });\n            },\n            'Component', []);\n\n    return mod;\n};\n", "src/lib/goog/__init__.py": "", "src/lib/goog/math/__init__.js": "var $builtinmodule = function(name)\n{\n    goog.require('goog.math');\n\n    // todo; need to convert long -> number\n    //       not super useful since it'll go double in JS and\n    //       then lose precision and generally kind of suck.\n\n    var mod = {};\n\n    mod.randomInt = new Sk.builtin.func(function(a)\n            {\n                return goog.math.randomInt(a);\n            });\n\n    mod.uniformRandom = new Sk.builtin.func(function(a, b)\n            {\n                return goog.math.uniformRandom(a, b);\n            });\n\n    mod.clamp = new Sk.builtin.func(function(value, min, max)\n            {\n                return goog.math.clamp(value, min, max);\n            });\n\n    mod.modulo = new Sk.builtin.func(function(a, b)\n            {\n                return goog.math.modulo(a, b);\n            });\n\n    mod.lerp = new Sk.builtin.func(function(a, b, x)\n            {\n                return goog.math.lerp(a, b, x);\n            });\n\n    // todo; opt_ ?\n    mod.nearlyEquals = new Sk.builtin.func(function(a, b, opt_tolerance)\n            {\n                return goog.math.nearlyEquals(a, b, opt_tolerance);\n            });\n\n    mod.standardAngle = new Sk.builtin.func(function(angleDegrees)\n            {\n                return goog.math.standardAngle(angleDegrees);\n            });\n\n    mod.toRadians = new Sk.builtin.func(function(angleDegrees)\n            {\n                return goog.math.toRadians(angleDegrees);\n            });\n\n    mod.toDegrees = new Sk.builtin.func(function(angleDegrees)\n            {\n                return goog.math.toDegrees(angleDegrees);\n            });\n\n    mod.angleDx = new Sk.builtin.func(function(degrees, radius)\n            {\n                return goog.math.angleDx(degrees, radius);\n            });\n\n    mod.angleDy = new Sk.builtin.func(function(degrees, radius)\n            {\n                return goog.math.angleDy(degrees, radius);\n            });\n\n    mod.angle = new Sk.builtin.func(function(x1, y1, x2, y2)\n            {\n                return goog.math.angle(x1, y1, x2, y2);\n            });\n\n    mod.angleDifference = new Sk.builtin.func(function(startAngle, endAngle)\n            {\n                return goog.math.angleDifference(startAngle, endAngle);\n            });\n\n    mod.sign = new Sk.builtin.func(function(x)\n            {\n                return goog.math.sign(x);\n            });\n\n    // todo; opt_ ?\n    mod.longestCommonSubsequence = new Sk.builtin.func(function(array1, array2, opt_compareFn, opt_collectorFn)\n            {\n                return Sk.ffi.remapToPy(\n                    goog.math.longestCommonSubsequence(\n                        Sk.ffi.remapToJs(array1),\n                        Sk.ffi.remapToJs(array2),\n                        Sk.ffi.callback(opt_compareFn),\n                        Sk.ffi.callback(opt_collectorFn)));\n            });\n\n    mod.sum = new Sk.builtin.func(function()\n            {\n                goog.asserts.fail(\"varargs\");\n            });\n\n    mod.average = new Sk.builtin.func(function()\n            {\n                goog.asserts.fail(\"varargs\");\n            });\n\n    mod.standardDeviation = new Sk.builtin.func(function()\n            {\n                goog.asserts.fail(\"varargs\");\n            });\n\n    mod.isInt = new Sk.builtin.func(function(num)\n            {\n                return goog.math.isInt(num);\n            });\n\n    mod.isFiniteNumber = new Sk.builtin.func(function(num)\n            {\n                return goog.math.isFiniteNumber(num);\n            });\n\n\n    goog.require('goog.math.Coordinate');\n    var coord = function($gbl, $loc)\n    {\n        $loc.__init__ = new Sk.builtin.func(function(self, opt_x, opt_y)\n                {\n                    self.v = new goog.math.Coordinate(opt_x, opt_y);\n                });\n\n        $loc.clone = new Sk.builtin.func(function(self)\n                {\n                    return Sk.ffi.stdwrap(mod.Coordinate, self.v.clone());\n                });\n\n        $loc.toString = new Sk.builtin.func(function(self)\n                {\n                    return new Sk.builtin.str(self.v.toString());\n                });\n        $loc.__repr__ = $loc.toString;\n\n        $loc.equals = new Sk.builtin.func(function(a, b)\n                {\n                    return goog.math.Coordinate.equals(a.v, b.v);\n                });\n\n        $loc.distance = new Sk.builtin.func(function(a, b)\n                {\n                    return goog.math.Coordinate.distance(a.v, b.v);\n                });\n\n        $loc.squaredDistance = new Sk.builtin.func(function(a, b)\n                {\n                    return goog.math.Coordinate.squaredDistance(a.v, b.v);\n                });\n\n        $loc.difference = new Sk.builtin.func(function(a, b)\n                {\n                    return Sk.ffi.stdwrap(mod.Coordinate, goog.math.Coordinate.difference(a.v, b.v));\n                });\n\n        $loc.sum = new Sk.builtin.func(function(a, b)\n                {\n                    return Sk.ffi.stdwrap(mod.Coordinate, goog.math.Coordinate.sum(a.v, b.v));\n                });\n\n\n    };\n    mod.Coordinate = Sk.misceval.buildClass(mod, coord, 'Coordinate', []);\n\n\n    goog.require('goog.math.Vec2');\n    var vec2 = function($gbl, $loc)\n    {\n        $loc.__init__ = new Sk.builtin.func(function(self, opt_x, opt_y)\n                {\n                    self.v = new goog.math.Vec2(opt_x, opt_y);\n                });\n\n        $loc.randomUnit = new Sk.builtin.func(function()\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.randomUnit());\n                });\n\n        $loc.random = new Sk.builtin.func(function()\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.random());\n                });\n\n        $loc.clone = new Sk.builtin.func(function(self)\n                {\n                    return new Sk.ffi.stdwrap(mod.Vec2, self.v.clone());\n                });\n\n        $loc.fromCoordinate = new Sk.builtin.func(function(a)\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.fromCoordinate(a.v));\n                });\n\n        $loc.magnitude = new Sk.builtin.func(function(self)\n                {\n                    return self.v.magnitude();\n                });\n\n        $loc.squaredMagnitude = new Sk.builtin.func(function(self)\n                {\n                    return self.v.squaredMagnitude();\n                });\n\n        $loc.scale = new Sk.builtin.func(function(self, s)\n                {\n                    self.v.scale(s);\n                });\n\n        $loc.invert = new Sk.builtin.func(function(self)\n                {\n                    self.v.invert();\n                });\n\n        $loc.normalize = new Sk.builtin.func(function(self)\n                {\n                    self.v.normalize();\n                });\n\n        $loc.add = new Sk.builtin.func(function(self, b)\n                {\n                    self.v.add(b.v);\n                });\n\n        $loc.subtract = new Sk.builtin.func(function(self, b)\n                {\n                    self.v.subtract(b.v);\n                });\n\n        $loc.equals = new Sk.builtin.func(function(self, b)\n                {\n                    return self.v.equals(b.v);\n                });\n\n        $loc.sum = new Sk.builtin.func(function(a, b)\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.sum(a.v, b.v));\n                });\n\n        $loc.difference = new Sk.builtin.func(function(a, b)\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.difference(a.v, b.v));\n                });\n\n        $loc.dot = new Sk.builtin.func(function(a, b)\n                {\n                    return goog.math.Vec2.dot(a.v, b.v);\n                });\n\n        $loc.lerp = new Sk.builtin.func(function(a, b, x)\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.lerp(a.v, b.v, x));\n                });\n    };\n    mod.Vec2 = Sk.misceval.buildClass(mod, vec2, 'Vec2', [ mod.Coordinate ]);\n\n    return mod;\n};\n", "src/builtin/sys.js": "var $builtinmodule = function(name)\n{\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (var i = 0; i < argv.length; ++i)\n        args.push(new Sk.builtin.str(argv[i]));\n    sys.argv = new Sk.builtins['list'](args);\n\n    sys.copyright = Sk.builtin['str'](\"Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n\");\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.debug = new Sk.builtin.func(function() {\n        debugger;\n    });\n\n    return sys;\n};\n", "src/builtin/unittest.py": "#!/usr/bin/env python\n'''\nPython unit testing framework, based on Erich Gamma's JUnit and Kent Beck's\nSmalltalk testing framework.\n\nThis module contains the core framework classes that form the basis of\nspecific test cases and suites (TestCase, TestSuite etc.), and also a\ntext-based utility class for running the tests and reporting the results\n (TextTestRunner).\n\nSimple usage:\n\n    import unittest\n\n    class IntegerArithmenticTestCase(unittest.TestCase):\n        def testAdd(self):  ## test method names begin 'test*'\n            self.assertEquals((1 + 2), 3)\n            self.assertEquals(0 + 1, 1)\n        def testMultiply(self):\n            self.assertEquals((0 * 10), 0)\n            self.assertEquals((5 * 8), 40)\n\n    if __name__ == '__main__':\n        unittest.main()\n\nFurther information is available in the bundled documentation, and from\n\n  http://docs.python.org/lib/module-unittest.html\n\nCopyright (c) 1999-2003 Steve Purcell\nThis module is free software, and you may redistribute it and/or modify\nit under the same terms as Python itself, so long as this copyright message\nand disclaimer are retained in their original form.\n\nIN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,\nSPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF\nTHIS CODE, EVEN IF THE AUTHOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\nDAMAGE.\n\nTHE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\nPARTICULAR PURPOSE.  THE CODE PROVIDED HEREUNDER IS ON AN \"AS IS\" BASIS,\nAND THERE IS NO OBLIGATION WHATSOEVER TO PROVIDE MAINTENANCE,\nSUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n'''\n\n__author__ = \"Steve Purcell\"\n__email__ = \"stephen_purcell at yahoo dot com\"\n__version__ = \"#Revision: 1.63 $\"[11:-2]\n\nimport time\nimport sys\nimport traceback\nimport os\nimport types\n\n##############################################################################\n# Exported classes and functions\n##############################################################################\n__all__ = ['TestResult', 'TestCase', 'TestSuite', 'TextTestRunner',\n           'TestLoader', 'FunctionTestCase', 'main', 'defaultTestLoader']\n\n# Expose obsolete functions for backwards compatibility\n__all__.extend(['getTestCaseNames', 'makeSuite', 'findTestCases'])\n\n\n##############################################################################\n# Backward compatibility\n##############################################################################\nif sys.version_info[:2] < (2, 2):\n    def isinstance(obj, clsinfo):\n        import __builtin__\n        if type(clsinfo) in (tuple, list):\n            for cls in clsinfo:\n                if cls is type: cls = types.ClassType\n                if __builtin__.isinstance(obj, cls):\n                    return 1\n            return 0\n        else: return __builtin__.isinstance(obj, clsinfo)\n\ndef _CmpToKey(mycmp):\n    'Convert a cmp= function into a key= function'\n    class K(object):\n        def __init__(self, obj):\n            self.obj = obj\n        def __lt__(self, other):\n            return mycmp(self.obj, other.obj) == -1\n    return K\n\n##############################################################################\n# Test framework core\n##############################################################################\n\n# All classes defined herein are 'new-style' classes, allowing use of 'super()'\n__metaclass__ = type\n\ndef _strclass(cls):\n    return \"%s.%s\" % (cls.__module__, cls.__name__)\n\n__unittest = 1\n\nclass TestResult:\n    \"\"\"Holder for test result information.\n\n    Test results are automatically managed by the TestCase and TestSuite\n    classes, and do not need to be explicitly manipulated by writers of tests.\n\n    Each instance holds the total number of tests run, and collections of\n    failures and errors that occurred among those test runs. The collections\n    contain tuples of (testcase, exceptioninfo), where exceptioninfo is the\n    formatted traceback of the error that occurred.\n    \"\"\"\n    def __init__(self):\n        self.failures = []\n        self.errors = []\n        self.testsRun = 0\n        self.shouldStop = False\n\n    def startTest(self, test):\n        \"Called when the given test is about to be run\"\n        self.testsRun = self.testsRun + 1\n\n    def stopTest(self, test):\n        \"Called when the given test has been run\"\n        pass\n\n    def addError(self, test, err):\n        \"\"\"Called when an error has occurred. 'err' is a tuple of values as\n        returned by sys.exc_info().\n        \"\"\"\n        self.errors.append((test, self._exc_info_to_string(err, test)))\n\n    def addFailure(self, test, err):\n        \"\"\"Called when an error has occurred. 'err' is a tuple of values as\n        returned by sys.exc_info().\"\"\"\n        self.failures.append((test, self._exc_info_to_string(err, test)))\n\n    def addSuccess(self, test):\n        \"Called when a test has completed successfully\"\n        pass\n\n    def wasSuccessful(self):\n        \"Tells whether or not this result was a success\"\n        return len(self.failures) == len(self.errors) == 0\n\n    def stop(self):\n        \"Indicates that the tests should be aborted\"\n        self.shouldStop = True\n\n    def _exc_info_to_string(self, err, test):\n        \"\"\"Converts a sys.exc_info()-style tuple of values into a string.\"\"\"\n        exctype, value, tb = err\n        # Skip test runner traceback levels\n        while tb and self._is_relevant_tb_level(tb):\n            tb = tb.tb_next\n        if exctype is test.failureException:\n            # Skip assert*() traceback levels\n            length = self._count_relevant_tb_levels(tb)\n            return ''.join(traceback.format_exception(exctype, value, tb, length))\n        return ''.join(traceback.format_exception(exctype, value, tb))\n\n    def _is_relevant_tb_level(self, tb):\n        return '__unittest' in tb.tb_frame.f_globals\n\n    def _count_relevant_tb_levels(self, tb):\n        length = 0\n        while tb and not self._is_relevant_tb_level(tb):\n            length += 1\n            tb = tb.tb_next\n        return length\n\n    def __repr__(self):\n        return \"<%s run=%i errors=%i failures=%i>\" % \\\n               (_strclass(self.__class__), self.testsRun, len(self.errors),\n                len(self.failures))\n\nclass TestCase:\n    \"\"\"A class whose instances are single test cases.\n\n    By default, the test code itself should be placed in a method named\n    'runTest'.\n\n    If the fixture may be used for many test cases, create as\n    many test methods as are needed. When instantiating such a TestCase\n    subclass, specify in the constructor arguments the name of the test method\n    that the instance is to execute.\n\n    Test authors should subclass TestCase for their own tests. Construction\n    and deconstruction of the test's environment ('fixture') can be\n    implemented by overriding the 'setUp' and 'tearDown' methods respectively.\n\n    If it is necessary to override the __init__ method, the base class\n    __init__ method must always be called. It is important that subclasses\n    should not change the signature of their __init__ method, since instances\n    of the classes are instantiated automatically by parts of the framework\n    in order to be run.\n    \"\"\"\n\n    # This attribute determines which exception will be raised when\n    # the instance's assertion methods fail; test methods raising this\n    # exception will be deemed to have 'failed' rather than 'errored'\n\n    failureException = AssertionError\n\n    def __init__(self, methodName='runTest'):\n        \"\"\"Create an instance of the class that will use the named test\n           method when executed. Raises a ValueError if the instance does\n           not have a method with the specified name.\n        \"\"\"\n        try:\n            self._testMethodName = methodName\n            testMethod = getattr(self, methodName)\n            self._testMethodDoc = testMethod.__doc__\n        except AttributeError:\n            raise ValueError, \"no such test method in %s: %s\" % \\\n                  (self.__class__, methodName)\n\n    def setUp(self):\n        \"Hook method for setting up the test fixture before exercising it.\"\n        pass\n\n    def tearDown(self):\n        \"Hook method for deconstructing the test fixture after testing it.\"\n        pass\n\n    def countTestCases(self):\n        return 1\n\n    def defaultTestResult(self):\n        return TestResult()\n\n    def shortDescription(self):\n        \"\"\"Returns a one-line description of the test, or None if no\n        description has been provided.\n\n        The default implementation of this method returns the first line of\n        the specified test method's docstring.\n        \"\"\"\n        doc = self._testMethodDoc\n        return doc and doc.split(\"\\n\")[0].strip() or None\n\n    def id(self):\n        return \"%s.%s\" % (_strclass(self.__class__), self._testMethodName)\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self._testMethodName == other._testMethodName\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self._testMethodName))\n\n    def __str__(self):\n        return \"%s (%s)\" % (self._testMethodName, _strclass(self.__class__))\n\n    def __repr__(self):\n        return \"<%s testMethod=%s>\" % \\\n               (_strclass(self.__class__), self._testMethodName)\n\n    def run(self, result=None):\n        if result is None: result = self.defaultTestResult()\n        result.startTest(self)\n        testMethod = getattr(self, self._testMethodName)\n        try:\n            try:\n                self.setUp()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                return\n\n            ok = False\n            try:\n                testMethod()\n                ok = True\n            except self.failureException:\n                result.addFailure(self, self._exc_info())\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n\n            try:\n                self.tearDown()\n            except KeyboardInterrupt:\n                raise\n            except:\n                result.addError(self, self._exc_info())\n                ok = False\n            if ok: result.addSuccess(self)\n        finally:\n            result.stopTest(self)\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        \"\"\"Run the test without collecting errors in a TestResult\"\"\"\n        self.setUp()\n        getattr(self, self._testMethodName)()\n        self.tearDown()\n\n    def _exc_info(self):\n        \"\"\"Return a version of sys.exc_info() with the traceback frame\n           minimised; usually the top level of the traceback frame is not\n           needed.\n        \"\"\"\n        return sys.exc_info()\n\n    def fail(self, msg=None):\n        \"\"\"Fail immediately, with the given message.\"\"\"\n        raise self.failureException, msg\n\n    def failIf(self, expr, msg=None):\n        \"Fail the test if the expression is true.\"\n        if expr: raise self.failureException, msg\n\n    def failUnless(self, expr, msg=None):\n        \"\"\"Fail the test unless the expression is true.\"\"\"\n        if not expr: raise self.failureException, msg\n\n    def failUnlessRaises(self, excClass, callableObj, *args, **kwargs):\n        \"\"\"Fail unless an exception of class excClass is thrown\n           by callableObj when invoked with arguments args and keyword\n           arguments kwargs. If a different type of exception is\n           thrown, it will not be caught, and the test case will be\n           deemed to have suffered an error, exactly as for an\n           unexpected exception.\n        \"\"\"\n        try:\n            callableObj(*args, **kwargs)\n        except excClass:\n            return\n        else:\n            if hasattr(excClass,'__name__'): excName = excClass.__name__\n            else: excName = str(excClass)\n            raise self.failureException, \"%s not raised\" % excName\n\n    def failUnlessEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by the '=='\n           operator.\n        \"\"\"\n        if not first == second:\n            raise self.failureException, \\\n                  (msg or '%r != %r' % (first, second))\n\n    def failIfEqual(self, first, second, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by the '=='\n           operator.\n        \"\"\"\n        if first == second:\n            raise self.failureException, \\\n                  (msg or '%r == %r' % (first, second))\n\n    def failUnlessAlmostEqual(self, first, second, places=7, msg=None):\n        \"\"\"Fail if the two objects are unequal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        \"\"\"\n        if round(abs(second-first), places) != 0:\n            raise self.failureException, \\\n                  (msg or '%r != %r within %r places' % (first, second, places))\n\n    def failIfAlmostEqual(self, first, second, places=7, msg=None):\n        \"\"\"Fail if the two objects are equal as determined by their\n           difference rounded to the given number of decimal places\n           (default 7) and comparing to zero.\n\n           Note that decimal places (from zero) are usually not the same\n           as significant digits (measured from the most signficant digit).\n        \"\"\"\n        if round(abs(second-first), places) == 0:\n            raise self.failureException, \\\n                  (msg or '%r == %r within %r places' % (first, second, places))\n\n    # Synonyms for assertion methods\n\n    assertEqual = assertEquals = failUnlessEqual\n\n    assertNotEqual = assertNotEquals = failIfEqual\n\n    assertAlmostEqual = assertAlmostEquals = failUnlessAlmostEqual\n\n    assertNotAlmostEqual = assertNotAlmostEquals = failIfAlmostEqual\n\n    assertRaises = failUnlessRaises\n\n    assert_ = assertTrue = failUnless\n\n    assertFalse = failIf\n\n\n\nclass TestSuite:\n    \"\"\"A test suite is a composite test consisting of a number of TestCases.\n\n    For use, create an instance of TestSuite, then add test case instances.\n    When all tests have been added, the suite can be passed to a test\n    runner, such as TextTestRunner. It will run the individual test cases\n    in the order in which they were added, aggregating the results. When\n    subclassing, do not forget to call the base class constructor.\n    \"\"\"\n    def __init__(self, tests=()):\n        self._tests = []\n        self.addTests(tests)\n\n    def __repr__(self):\n        return \"<%s tests=%s>\" % (_strclass(self.__class__), self._tests)\n\n    __str__ = __repr__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n        return self._tests == other._tests\n\n    def __ne__(self, other):\n        return not self == other\n\n    # Can't guarantee hash invariant, so flag as unhashable\n    __hash__ = None\n\n    def __iter__(self):\n        return iter(self._tests)\n\n    def countTestCases(self):\n        cases = 0\n        for test in self._tests:\n            cases += test.countTestCases()\n        return cases\n\n    def addTest(self, test):\n        # sanity checks\n        if not hasattr(test, '__call__'):\n            raise TypeError(\"the test to add must be callable\")\n        if (isinstance(test, (type, types.ClassType)) and\n            issubclass(test, (TestCase, TestSuite))):\n            raise TypeError(\"TestCases and TestSuites must be instantiated \"\n                            \"before passing them to addTest()\")\n        self._tests.append(test)\n\n    def addTests(self, tests):\n        if isinstance(tests, basestring):\n            raise TypeError(\"tests must be an iterable of tests, not a string\")\n        for test in tests:\n            self.addTest(test)\n\n    def run(self, result):\n        for test in self._tests:\n            if result.shouldStop:\n                break\n            test(result)\n        return result\n\n    def __call__(self, *args, **kwds):\n        return self.run(*args, **kwds)\n\n    def debug(self):\n        \"\"\"Run the tests without collecting errors in a TestResult\"\"\"\n        for test in self._tests: test.debug()\n\n\nclass FunctionTestCase(TestCase):\n    \"\"\"A test case that wraps a test function.\n\n    This is useful for slipping pre-existing test functions into the\n    unittest framework. Optionally, set-up and tidy-up functions can be\n    supplied. As with TestCase, the tidy-up ('tearDown') function will\n    always be called if the set-up ('setUp') function ran successfully.\n    \"\"\"\n\n    def __init__(self, testFunc, setUp=None, tearDown=None,\n                 description=None):\n        TestCase.__init__(self)\n        self.__setUpFunc = setUp\n        self.__tearDownFunc = tearDown\n        self.__testFunc = testFunc\n        self.__description = description\n\n    def setUp(self):\n        if self.__setUpFunc is not None:\n            self.__setUpFunc()\n\n    def tearDown(self):\n        if self.__tearDownFunc is not None:\n            self.__tearDownFunc()\n\n    def runTest(self):\n        self.__testFunc()\n\n    def id(self):\n        return self.__testFunc.__name__\n\n    def __eq__(self, other):\n        if type(self) is not type(other):\n            return False\n\n        return self.__setUpFunc == other.__setUpFunc and \\\n               self.__tearDownFunc == other.__tearDownFunc and \\\n               self.__testFunc == other.__testFunc and \\\n               self.__description == other.__description\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((type(self), self.__setUpFunc, self.__tearDownFunc,\n                                           self.__testFunc, self.__description))\n\n    def __str__(self):\n        return \"%s (%s)\" % (_strclass(self.__class__), self.__testFunc.__name__)\n\n    def __repr__(self):\n        return \"<%s testFunc=%s>\" % (_strclass(self.__class__), self.__testFunc)\n\n    def shortDescription(self):\n        if self.__description is not None: return self.__description\n        doc = self.__testFunc.__doc__\n        return doc and doc.split(\"\\n\")[0].strip() or None\n\n\n\n##############################################################################\n# Locating and loading tests\n##############################################################################\n\nclass TestLoader:\n    \"\"\"This class is responsible for loading tests according to various\n    criteria and returning them wrapped in a TestSuite\n    \"\"\"\n    testMethodPrefix = 'test'\n    sortTestMethodsUsing = cmp\n    suiteClass = TestSuite\n\n    def loadTestsFromTestCase(self, testCaseClass):\n        \"\"\"Return a suite of all tests cases contained in testCaseClass\"\"\"\n        if issubclass(testCaseClass, TestSuite):\n            raise TypeError(\"Test cases should not be derived from TestSuite. Maybe you meant to derive from TestCase?\")\n        testCaseNames = self.getTestCaseNames(testCaseClass)\n        if not testCaseNames and hasattr(testCaseClass, 'runTest'):\n            testCaseNames = ['runTest']\n        return self.suiteClass(map(testCaseClass, testCaseNames))\n\n    def loadTestsFromModule(self, module):\n        \"\"\"Return a suite of all tests cases contained in the given module\"\"\"\n        tests = []\n        for name in dir(module):\n            obj = getattr(module, name)\n            if (isinstance(obj, (type, types.ClassType)) and\n                issubclass(obj, TestCase)):\n                tests.append(self.loadTestsFromTestCase(obj))\n        return self.suiteClass(tests)\n\n    def loadTestsFromName(self, name, module=None):\n        \"\"\"Return a suite of all tests cases given a string specifier.\n\n        The name may resolve either to a module, a test case class, a\n        test method within a test case class, or a callable object which\n        returns a TestCase or TestSuite instance.\n\n        The method optionally resolves the names relative to a given module.\n        \"\"\"\n        parts = name.split('.')\n        if module is None:\n            parts_copy = parts[:]\n            while parts_copy:\n                try:\n                    module = __import__('.'.join(parts_copy))\n                    break\n                except ImportError:\n                    del parts_copy[-1]\n                    if not parts_copy: raise\n            parts = parts[1:]\n        obj = module\n        for part in parts:\n            parent, obj = obj, getattr(obj, part)\n\n        if type(obj) == types.ModuleType:\n            return self.loadTestsFromModule(obj)\n        elif (isinstance(obj, (type, types.ClassType)) and\n              issubclass(obj, TestCase)):\n            return self.loadTestsFromTestCase(obj)\n        elif (type(obj) == types.UnboundMethodType and\n              isinstance(parent, (type, types.ClassType)) and\n              issubclass(parent, TestCase)):\n            return TestSuite([parent(obj.__name__)])\n        elif isinstance(obj, TestSuite):\n            return obj\n        elif hasattr(obj, '__call__'):\n            test = obj()\n            if isinstance(test, TestSuite):\n                return test\n            elif isinstance(test, TestCase):\n                return TestSuite([test])\n            else:\n                raise TypeError(\"calling %s returned %s, not a test\" %\n                                (obj, test))\n        else:\n            raise TypeError(\"don't know how to make test from: %s\" % obj)\n\n    def loadTestsFromNames(self, names, module=None):\n        \"\"\"Return a suite of all tests cases found using the given sequence\n        of string specifiers. See 'loadTestsFromName()'.\n        \"\"\"\n        suites = [self.loadTestsFromName(name, module) for name in names]\n        return self.suiteClass(suites)\n\n    def getTestCaseNames(self, testCaseClass):\n        \"\"\"Return a sorted sequence of method names found within testCaseClass\n        \"\"\"\n        def isTestMethod(attrname, testCaseClass=testCaseClass, prefix=self.testMethodPrefix):\n            return attrname.startswith(prefix) and hasattr(getattr(testCaseClass, attrname), '__call__')\n        testFnNames = filter(isTestMethod, dir(testCaseClass))\n        if self.sortTestMethodsUsing:\n            testFnNames.sort(key=_CmpToKey(self.sortTestMethodsUsing))\n        return testFnNames\n\n\n\ndefaultTestLoader = TestLoader()\n\n\n##############################################################################\n# Patches for old functions: these functions should be considered obsolete\n##############################################################################\n\ndef _makeLoader(prefix, sortUsing, suiteClass=None):\n    loader = TestLoader()\n    loader.sortTestMethodsUsing = sortUsing\n    loader.testMethodPrefix = prefix\n    if suiteClass: loader.suiteClass = suiteClass\n    return loader\n\ndef getTestCaseNames(testCaseClass, prefix, sortUsing=cmp):\n    return _makeLoader(prefix, sortUsing).getTestCaseNames(testCaseClass)\n\ndef makeSuite(testCaseClass, prefix='test', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromTestCase(testCaseClass)\n\ndef findTestCases(module, prefix='test', sortUsing=cmp, suiteClass=TestSuite):\n    return _makeLoader(prefix, sortUsing, suiteClass).loadTestsFromModule(module)\n\n\n##############################################################################\n# Text UI\n##############################################################################\n\nclass _WritelnDecorator:\n    \"\"\"Used to decorate file-like objects with a handy 'writeln' method\"\"\"\n    def __init__(self,stream):\n        self.stream = stream\n\n    def __getattr__(self, attr):\n        return getattr(self.stream,attr)\n\n    def writeln(self, arg=None):\n        if arg: self.write(arg)\n        self.write('\\n') # text-mode streams translate to \\r\\n if needed\n\n\nclass _TextTestResult(TestResult):\n    \"\"\"A test result class that can print formatted text results to a stream.\n\n    Used by TextTestRunner.\n    \"\"\"\n    separator1 = '=' * 70\n    separator2 = '-' * 70\n\n    def __init__(self, stream, descriptions, verbosity):\n        TestResult.__init__(self)\n        self.stream = stream\n        self.showAll = verbosity > 1\n        self.dots = verbosity == 1\n        self.descriptions = descriptions\n\n    def getDescription(self, test):\n        if self.descriptions:\n            return test.shortDescription() or str(test)\n        else:\n            return str(test)\n\n    def startTest(self, test):\n        TestResult.startTest(self, test)\n        if self.showAll:\n            self.stream.write(self.getDescription(test))\n            self.stream.write(\" ... \")\n            self.stream.flush()\n\n    def addSuccess(self, test):\n        TestResult.addSuccess(self, test)\n        if self.showAll:\n            self.stream.writeln(\"ok\")\n        elif self.dots:\n            self.stream.write('.')\n            self.stream.flush()\n\n    def addError(self, test, err):\n        TestResult.addError(self, test, err)\n        if self.showAll:\n            self.stream.writeln(\"ERROR\")\n        elif self.dots:\n            self.stream.write('E')\n            self.stream.flush()\n\n    def addFailure(self, test, err):\n        TestResult.addFailure(self, test, err)\n        if self.showAll:\n            self.stream.writeln(\"FAIL\")\n        elif self.dots:\n            self.stream.write('F')\n            self.stream.flush()\n\n    def printErrors(self):\n        if self.dots or self.showAll:\n            self.stream.writeln()\n        self.printErrorList('ERROR', self.errors)\n        self.printErrorList('FAIL', self.failures)\n\n    def printErrorList(self, flavour, errors):\n        for test, err in errors:\n            self.stream.writeln(self.separator1)\n            self.stream.writeln(\"%s: %s\" % (flavour,self.getDescription(test)))\n            self.stream.writeln(self.separator2)\n            self.stream.writeln(\"%s\" % err)\n\n\nclass TextTestRunner:\n    \"\"\"A test runner class that displays results in textual form.\n\n    It prints out the names of tests as they are run, errors as they\n    occur, and a summary of the results at the end of the test run.\n    \"\"\"\n    def __init__(self, stream=sys.stderr, descriptions=1, verbosity=1):\n        self.stream = _WritelnDecorator(stream)\n        self.descriptions = descriptions\n        self.verbosity = verbosity\n\n    def _makeResult(self):\n        return _TextTestResult(self.stream, self.descriptions, self.verbosity)\n\n    def run(self, test):\n        \"Run the given test case or test suite.\"\n        result = self._makeResult()\n        startTime = time.time()\n        test(result)\n        stopTime = time.time()\n        timeTaken = stopTime - startTime\n        result.printErrors()\n        self.stream.writeln(result.separator2)\n        run = result.testsRun\n        self.stream.writeln(\"Ran %d test%s in %.3fs\" %\n                            (run, run != 1 and \"s\" or \"\", timeTaken))\n        self.stream.writeln()\n        if not result.wasSuccessful():\n            self.stream.write(\"FAILED (\")\n            failed, errored = map(len, (result.failures, result.errors))\n            if failed:\n                self.stream.write(\"failures=%d\" % failed)\n            if errored:\n                if failed: self.stream.write(\", \")\n                self.stream.write(\"errors=%d\" % errored)\n            self.stream.writeln(\")\")\n        else:\n            self.stream.writeln(\"OK\")\n        return result\n\n\n\n##############################################################################\n# Facilities for running tests from the command line\n##############################################################################\n\nclass TestProgram:\n    \"\"\"A command-line program that runs a set of tests; this is primarily\n       for making test modules conveniently executable.\n    \"\"\"\n    USAGE = \"\"\"\\\nUsage: %(progName)s [options] [test] [...]\n\nOptions:\n  -h, --help       Show this message\n  -v, --verbose    Verbose output\n  -q, --quiet      Minimal output\n\nExamples:\n  %(progName)s                               - run default set of tests\n  %(progName)s MyTestSuite                   - run suite 'MyTestSuite'\n  %(progName)s MyTestCase.testSomething      - run MyTestCase.testSomething\n  %(progName)s MyTestCase                    - run all 'test*' test methods\n                                               in MyTestCase\n\"\"\"\n    def __init__(self, module='__main__', defaultTest=None,\n                 argv=None, testRunner=None,\n                 testLoader=defaultTestLoader):\n        if type(module) == type(''):\n            self.module = __import__(module)\n            for part in module.split('.')[1:]:\n                self.module = getattr(self.module, part)\n        else:\n            self.module = module\n        if argv is None:\n            argv = sys.argv\n        self.verbosity = 1\n        self.defaultTest = defaultTest\n        self.testRunner = testRunner\n        self.testLoader = testLoader\n        self.progName = os.path.basename(argv[0])\n        self.parseArgs(argv)\n        self.runTests()\n\n    def usageExit(self, msg=None):\n        if msg: print msg\n        print self.USAGE % self.__dict__\n        sys.exit(2)\n\n    def parseArgs(self, argv):\n        import getopt\n        try:\n            options, args = getopt.getopt(argv[1:], 'hHvq',\n                                          ['help','verbose','quiet'])\n            for opt, value in options:\n                if opt in ('-h','-H','--help'):\n                    self.usageExit()\n                if opt in ('-q','--quiet'):\n                    self.verbosity = 0\n                if opt in ('-v','--verbose'):\n                    self.verbosity = 2\n            if len(args) == 0 and self.defaultTest is None:\n                self.test = self.testLoader.loadTestsFromModule(self.module)\n                return\n            if len(args) > 0:\n                self.testNames = args\n            else:\n                self.testNames = (self.defaultTest,)\n            self.createTests()\n        except getopt.error, msg:\n            self.usageExit(msg)\n\n    def createTests(self):\n        self.test = self.testLoader.loadTestsFromNames(self.testNames,\n                                                       self.module)\n\n    def runTests(self):\n        if self.testRunner is None:\n            self.testRunner = TextTestRunner\n\n        if isinstance(self.testRunner, (type, types.ClassType)):\n            try:\n                testRunner = self.testRunner(verbosity=self.verbosity)\n            except TypeError:\n                # didn't accept the verbosity argument\n                testRunner = self.testRunner()\n        else:\n            # it is assumed to be a TestRunner instance\n            testRunner = self.testRunner\n        result = testRunner.run(self.test)\n        sys.exit(not result.wasSuccessful())\n\nmain = TestProgram\n\n\n##############################################################################\n# Executing this module from the command line\n##############################################################################\n\nif __name__ == \"__main__\":\n    main(module=None)\n", "src/lib/goog/graphics/__init__.js": "var $builtinmodule = function(name)\n{\n    goog.require('goog.graphics');\n\n    var mod = {};\n\n    mod.createGraphics = new Sk.builtin.func(function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper)\n            {\n                return new Sk.ffi.stdwrap(mod.AbstractGraphics, goog.graphics.createGraphics(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper));\n            });\n\n    mod.createSimpleGraphics = new Sk.builtin.func(function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper)\n            {\n                return new Sk.ffi.stdwrap(mod.AbstractGraphics, goog.graphics.createSimpleGraphics(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper));\n            });\n\n\n    goog.require('goog.graphics.AbstractGraphics');\n\n    // todo; shortcut for this\n    var goog_ui_Component = Sk.importModule('goog.ui').tp$getattr('ui').tp$getattr('Component');\n    mod.AbstractGraphics = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.getCanvasElement = new Sk.builtin.func(function(self)\n                        {\n                            // todo; wrap\n                            return self.v.getCanvasElement();\n                        });\n\n                $loc.drawRect = new Sk.builtin.func(function(self, x, y, width, height, stroke, fill, opt_group)\n                        {\n                            // todo; wrap with RectElement\n                            return self.v.drawRect(x, y, width, height, Sk.ffi.unwrapn(stroke), Sk.ffi.unwrapn(fill), Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.drawImage = new Sk.builtin.func(function(self, x, y, width, height, src, opt_group)\n                        {\n                            // todo; wrap with ImageElement\n                            return self.v.drawImage(x, y, width, height, src.v, Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.drawCircle = new Sk.builtin.func(function(self, cx, cy, r, stroke, fill, opt_group)\n                        {\n                            // todo; wrap with EllipseElement\n                            return self.v.drawCircle(cx, cy, r, Sk.ffi.unwrapn(stroke), Sk.ffi.unwrapn(fill), Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.drawEllipse = new Sk.builtin.func(function(self, cx, cy, rx, ry, stroke, fill, opt_group)\n                        {\n                            // todo; wrap with EllipseElement\n                            return self.v.drawEllipse(cx, cy, rx, ry, Sk.ffi.unwrapn(stroke), Sk.ffi.unwrapn(fill), Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.drawPath = new Sk.builtin.func(function(self, path, stroke, fill, opt_group)\n                        {\n                            // todo; wrap with PathElement\n                            return self.v.drawPath(path.v, Sk.ffi.unwrapn(stroke), Sk.ffi.unwrapn(fill), Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.__repr__ = new Sk.builtin.func(function(self)\n                        {\n                            return new Sk.builtin.str(\"<AbstractGraphics instance>\");\n                        });\n            },\n            'AbstractGraphics', [ goog_ui_Component ]);\n\n    goog.require('goog.graphics.SolidFill');\n    mod.SolidFill = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, color, opt_opacity)\n                    {\n                        self.v = new goog.graphics.SolidFill(color.v, opt_opacity);\n                    });\n\n                $loc.getColor = new Sk.builtin.func(function(self)\n                    {\n                        return new Sk.builtin.str(self.v.getColor());\n                    });\n\n                $loc.getOpacity = new Sk.builtin.func(function(self)\n                    {\n                        return self.v.getOpacity();\n                    });\n            },\n            'SolidFill', []);\n\n    goog.require('goog.graphics.Stroke');\n    mod.Stroke = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, width, color)\n                    {\n                        self.v = new goog.graphics.Stroke(width, color.v);\n                    });\n\n                $loc.getWidth = new Sk.builtin.func(function(self)\n                    {\n                        return Sk.ffi.basicwrap(self.v.getWidth());\n                    });\n\n                $loc.getColor = new Sk.builtin.func(function(self)\n                    {\n                        return self.v.getColor();\n                    });\n            },\n            'Stroke', []);\n\n    goog.require('goog.graphics.Path');\n    mod.Path = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        self.v = new goog.graphics.Path();\n                    });\n\n                $loc.moveTo = new Sk.builtin.func(function(self, x, y)\n                    {\n                        self.v.moveTo(x, y);\n                        return self;\n                    });\n\n                $loc.lineTo = new Sk.builtin.func(function(self, x, y)\n                    {\n                        self.v.lineTo(x, y);\n                        return self;\n                    });\n\n                $loc.close = new Sk.builtin.func(function(self)\n                    {\n                        self.v.close();\n                        return self;\n                    });\n            },\n            'Path', []);\n\n    return mod;\n};\n", "src/lib/webgl/__init__.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; won't work compressed\n    mod.tp$name = \"webgl\";\n\n    //\n    // Setup code taken from 'tdl'. I tried to use more of it, but it's a bit\n    // broken.\n    //\n    var makeFailHTML = function(msg) {\n        return '' +\n            '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n            '<td align=\"center\">' +\n            '<div style=\"display: table-cell; vertical-align: middle;\">' +\n            '<div style=\"\">' + msg + '</div>' +\n            '</div>' +\n            '</td></tr></table>';\n    };\n\n    var GET_A_WEBGL_BROWSER = '' +\n        'This page requires a browser that supports WebGL.<br/>' +\n        '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n\n    var NEED_HARDWARE = '' +\n        \"It doesn't appear your computer can support WebGL.<br/>\" +\n        '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n  \n    var create3DContext = function(canvas) {\n        var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n        var context = null;\n        for (var ii = 0; ii < names.length; ++ii) {\n            try {\n                context = canvas.getContext(names[ii]);\n            } catch(e) {}\n            if (context) {\n                break;\n            }\n        }\n        if (context) {\n            // Disallow selection by default. This keeps the cursor from changing to an\n            // I-beam when the user clicks and drags.  It's easier on the eyes.\n            function returnFalse() {\n                return false;\n            }\n\n            canvas.onselectstart = returnFalse;\n            canvas.onmousedown = returnFalse;\n        }\n        return context;\n    };\n\n    var setupWebGL = function(canvasContainerId, opt_canvas) {\n        var container = document.getElementById(canvasContainerId);\n        var context;\n        if (!opt_canvas) {\n            opt_canvas = container.getElementsByTagName(\"canvas\")[0];\n        }\n        if (!opt_canvas) {\n            // this browser doesn't support the canvas tag at all. Not even 2d.\n            container.innerHTML = makeFailHTML(\n                    GET_A_WEBGL_BROWSER);\n            return;\n        }\n\n        var context = create3DContext(opt_canvas);\n        if (!context) {\n            // TODO(gman): fix to official way to detect that it's the user's machine, not the browser.\n            var browserStrings = navigator.userAgent.match(/(\\w+\\/.*? )/g);\n            var browsers = {};\n            try {\n                for (var b = 0; b < browserStrings.length; ++b) {\n                    var parts = browserStrings[b].match(/(\\w+)/g);\n                    var bb = [];\n                    for (var ii = 1; ii < parts.length; ++ii) {\n                        bb.push(parseInt(parts[ii]));\n                    }\n                    browsers[parts[0]] = bb;\n                }\n            } catch (e) {\n            }\n            if (browsers.Chrome &&\n                    (browsers.Chrome[0] > 7 ||\n                     (browsers.Chrome[0] == 7 && browsers.Chrome[1] > 0) ||\n                     (browsers.Chrome[0] == 7 && browsers.Chrome[1] == 0 && browsers.Chrome[2] >= 521))) {\n                container.innerHTML = makeFailHTML(\n                        NEED_HARDWARE);\n            } else {\n                container.innerHTML = makeFailHTML(\n                        GET_A_WEBGL_BROWSER);\n            }\n        }\n        return context;\n    };\n\n    mod.Context = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, canvasid)\n                    {\n                        var canvas = document.getElementById(canvasid.v);\n                        // NB: purposefully leak this to global because\n                        // everything wants it (esp. for constants it's a pain\n                        // to have to pass it to utility functions)\n                        /*var*/ gl = setupWebGL(canvasid.v, canvas)\n                        if (!gl)\n                            throw \"couldn't get webgl context, unsupported browser?\";\n\n                        self.gl = gl;\n                        // all (?) browsers that have webgl support\n                        // __proto__ too so we cheese out and just rip\n                        // them out of there rather than manually\n                        // enumerating the entire webgl api. it wouldn't\n                        // be too difficult to do it \"properly\", just\n                        // long.\n                        for (var k in gl.__proto__)\n                        {\n                            if (typeof gl.__proto__[k] === \"number\")\n                            {\n                                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str(k), gl.__proto__[k]);\n                            }\n                            else if (typeof gl.__proto__[k] === \"function\")\n                            {\n                                (function(key) {\n                                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str(k), new Sk.builtin.func(function()\n                                    {\n                                        var f = gl.__proto__[key];\n                                        // todo; assuming only basic\n                                        // type returns?\n                                        return f.apply(gl, arguments);\n                                    }));\n                                }(k));\n                            }\n                        }\n\n                        console.log(\"gl initialized\", gl, canvas, canvas.width, canvas.height);\n\n                        // set to cornflower so we know we're init'd at least\n                        gl.clearColor(100/255.0,149/255.0,237/255.0,1);\n                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n                        gl.viewport(0, 0, canvas.width, canvas.height);\n                        gl.clear(gl.COLOR_BUFFER_BIT);\n                        gl.flush();\n                    });\n\n                $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n                $loc.setDrawFunc = new Sk.builtin.func(function(self, func)\n                        {\n                            var startTime = (new Date()).getTime();\n                            var intervalId = setInterval(function() {\n                                    Sk.misceval.callsim(func, self, (new Date()).getTime() - startTime);\n                                    if (goog.global.shutdownGLContext)\n                                    {\n                                        clearInterval(intervalId);\n                                        console.log(\"gl draw function shutting down\");\n                                        return;\n                                    }\n                                }, 1000.0 / 60.0);\n                                \n                        });\n            },\n            'Context', []);\n\n    mod.Shader = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, gl, vertex, fragment)\n                        {\n                            self.gl = gl.gl;\n                            var gl = self.gl;\n                            self.program = gl.createProgram();\n                            var vs = gl.createShader(gl.VERTEX_SHADER);\n                            gl.shaderSource(vs, vertex.v);\n                            gl.compileShader(vs);\n                            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))\n                            {\n                                console.log(gl.getShaderInfoLog(vs));\n                                throw new Sk.builtin.SyntaxError(\"Error compiling vertex shader:\" + gl.getShaderInfoLog(vs));\n                            }\n                            gl.attachShader(self.program, vs);\n                            gl.deleteShader(vs);\n                            \n                            var fs = gl.createShader(gl.FRAGMENT_SHADER);\n                            gl.shaderSource(fs, fragment.v);\n                            gl.compileShader(fs);\n                            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))\n                            {\n                                console.log(gl.getShaderInfoLog(fs));\n                                throw new Sk.builtin.SyntaxError(\"Error compiling fragment shader:\" + gl.getShaderInfoLog(fs));\n                            }\n                            gl.attachShader(self.program, fs);\n                            gl.deleteShader(fs);\n\n                            gl.linkProgram(self.program);\n                            gl.useProgram(self.program);\n\n\n                            //\n                            //\n                            // Some more init code from 'tdl' (slightly\n                            // tweaked)\n                            //\n                            //\n\n                            var endsWith = function(haystack, needle) {\n                                return haystack.substr(haystack.length - needle.length) === needle;\n                            };\n\n                            // Look up attribs.\n                            var attribs = {\n                            };\n                            // Also make a plain table of the locs.\n                            var attribLocs = {\n                            };\n\n                            function createAttribSetter(info, index) {\n                                if (info.size != 1) {\n                                    throw(\"arrays of attribs not handled\");\n                                }\n                                return function(b) {\n                                    gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer());\n                                    gl.enableVertexAttribArray(index);\n                                    gl.vertexAttribPointer(\n                                            index, b.numComponents(), b.type(), false, b.stride(), b.offset());\n                                };\n                            }\n\n                            var numAttribs = gl.getProgramParameter(self.program, gl.ACTIVE_ATTRIBUTES);\n                            for (var ii = 0; ii < numAttribs; ++ii) {\n                                var info = gl.getActiveAttrib(self.program, ii);\n                                name = info.name;\n                                if (endsWith(name, \"[0]\")) {\n                                    name = name.substr(0, name.length - 3);\n                                }\n                                var index = gl.getAttribLocation(self.program, info.name);\n                                attribs[name] = createAttribSetter(info, index);\n                                attribLocs[name] = index\n                            }\n\n                            // Look up uniforms\n                            var numUniforms = gl.getProgramParameter(self.program, gl.ACTIVE_UNIFORMS);\n                            var uniforms = {\n                            };\n\n                            function createUniformSetter(info) {\n                                var loc = gl.getUniformLocation(self.program, info.name);\n                                var type = info.type;\n                                if (info.size > 1 && endsWith(info.name, \"[0]\")) {\n                                    // It's an array.\n                                    if (type == gl.FLOAT)\n                                        return function(v) { gl.uniform1fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC2)\n                                        return function(v) { gl.uniform2fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC3)\n                                        return function(v) { gl.uniform3fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC4)\n                                        return function(v) { gl.uniform4fv(loc, v); };\n                                    if (type == gl.INT)\n                                        return function(v) { gl.uniform1iv(loc, v); };\n                                    if (type == gl.INT_VEC2)\n                                        return function(v) { gl.uniform2iv(loc, v); };\n                                    if (type == gl.INT_VEC3)\n                                        return function(v) { gl.uniform3iv(loc, v); };\n                                    if (type == gl.INT_VEC4)\n                                        return function(v) { gl.uniform4iv(loc, v); };\n                                    if (type == gl.BOOL)\n                                        return function(v) { gl.uniform1iv(loc, v); };\n                                    if (type == gl.BOOL_VEC2)\n                                        return function(v) { gl.uniform2iv(loc, v); };\n                                    if (type == gl.BOOL_VEC3)\n                                        return function(v) { gl.uniform3iv(loc, v); };\n                                    if (type == gl.BOOL_VEC4)\n                                        return function(v) { gl.uniform4iv(loc, v); };\n                                    if (type == gl.FLOAT_MAT2)\n                                        return function(v) { gl.uniformMatrix2fv(loc, false, v); };\n                                    if (type == gl.FLOAT_MAT3)\n                                        return function(v) { gl.uniformMatrix3fv(loc, false, v); };\n                                    if (type == gl.FLOAT_MAT4)\n                                        return function(v) { gl.uniformMatrix4fv(loc, false, v); };\n                                    if (type == gl.SAMPLER_2D)\n                                        return function(v) { gl.uniform1iv(loc, v); };\n                                    if (type == gl.SAMPLER_CUBE_MAP)\n                                        return function(v) { gl.uniform1iv(loc, v); };\n                                    throw (\"unknown type: 0x\" + type.toString(16));\n                                } else {\n                                    if (type == gl.FLOAT)\n                                        return function(v) { gl.uniform1f(loc, v); };\n                                    if (type == gl.FLOAT_VEC2)\n                                        return function(v) { gl.uniform2fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC3)\n                                        return function(v) { gl.uniform3fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC4)\n                                        return function(v) { gl.uniform4fv(loc, v); };\n                                    if (type == gl.INT)\n                                        return function(v) { gl.uniform1i(loc, v); };\n                                    if (type == gl.INT_VEC2)\n                                        return function(v) { gl.uniform2iv(loc, v); };\n                                    if (type == gl.INT_VEC3)\n                                        return function(v) { gl.uniform3iv(loc, v); };\n                                    if (type == gl.INT_VEC4)\n                                        return function(v) { gl.uniform4iv(loc, v); };\n                                    if (type == gl.BOOL)\n                                        return function(v) { gl.uniform1i(loc, v); };\n                                    if (type == gl.BOOL_VEC2)\n                                        return function(v) { gl.uniform2iv(loc, v); };\n                                    if (type == gl.BOOL_VEC3)\n                                        return function(v) { gl.uniform3iv(loc, v); };\n                                    if (type == gl.BOOL_VEC4)\n                                        return function(v) { gl.uniform4iv(loc, v); };\n                                    if (type == gl.FLOAT_MAT2)\n                                        return function(v) { gl.uniformMatrix2fv(loc, false, v); };\n                                    if (type == gl.FLOAT_MAT3)\n                                        return function(v) { gl.uniformMatrix3fv(loc, false, v); };\n                                    if (type == gl.FLOAT_MAT4)\n                                        return function(v) { gl.uniformMatrix4fv(loc, false, v); };\n                                    if (type == gl.SAMPLER_2D)\n                                        return function(v) { gl.uniform1i(loc, v); };\n                                    if (type == gl.SAMPLER_CUBE)\n                                        return function(v) { gl.uniform1i(loc, v); };\n                                    throw (\"unknown type: 0x\" + type.toString(16));\n                                }\n                            }\n\n                            for (var ii = 0; ii < numUniforms; ++ii) {\n                                var info = gl.getActiveUniform(self.program, ii);\n                                name = info.name;\n                                if (endsWith(name, \"[0]\")) {\n                                    name = name.substr(0, name.length - 3);\n                                }\n                                uniforms[name] = createUniformSetter(info);\n                            }\n\n                            self.attrib = attribs;\n                            self.attribLoc = attribLocs;\n                            self.uniform = uniforms;\n                        });\n\n                $loc.setUniform = new Sk.builtin.func(function(self, uniform, value)\n                        {\n                            var func = self.uniform[uniform.v];\n                            if (func)\n                            {\n                                //console.log(\"SET UNI:\", uniform.v, value);\n                                func(Sk.ffi.remapToJs(value));\n                            }\n                        });\n\n                $loc.setUniform$impl = function(self, uniform, value)\n                        {\n                            var func = self.uniform[uniform];\n                            if (func)\n                            {\n                                //console.log(\"SET UNI:\", uniform, value);\n                                func(value);\n                            }\n                        };\n\n                $loc.use = new Sk.builtin.func(function(self)\n                        {\n                            self.gl.useProgram(self.program);\n                        });\n            },\n            'Shader', []);\n\n\n    mod.Float32Array = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, data)\n                        {\n                            if (typeof data === \"number\")\n                                self.v = new Float32Array(data);\n                            else\n                                self.v = new Float32Array(Sk.ffi.remapToJs(data));\n                        });\n\n                $loc.__repr__ = new Sk.builtin.func(function(self)\n                    {\n                        var copy = [];\n                        for (var i = 0; i < self.v.length; ++i)\n                            copy.push(self.v[i]);\n                        return new Sk.builtin.str(\"[\"+copy.join(', ')+\"]\");\n                    });\n\n            },\n            'Float32Array', []);\n\n\n    return mod;\n};\n", "src/builtin/this.py": "s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint \"\".join([d.get(c, c) for c in s])\n", "src/lib/webgl/math.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; should probably put this in a math package\n    mod.Mat44 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                        self.stack = [];\n                    });\n\n                $loc.push = new Sk.builtin.func(function(self)\n                    {\n                        self.stack.push(self.elements.slice(0));\n                    });\n\n                $loc.pop = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = self.stack.pop();\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0, 0.0,\n                                         0.0, 0.0, 1.0, 0.0,\n                                         0.0, 0.0, 0.0, 1.0];\n                    });\n\n                $loc.transform3 = new Sk.builtin.func(function(self, v)\n                    {\n                        var e = self.elements;\n                        return Sk.misceval.callsim(mod.Vec3,\n                            e[0] * v.x + e[4] * v.y + e[8] * v.z,\n                            e[1] * v.x + e[5] * v.y + e[9] * v.z,\n                            e[2] * v.x + e[6] * v.y + e[10] * v.z);\n                    });\n\n                $loc.scale = new Sk.builtin.func(function(self, sx, sy, sz)\n                        {\n                            self.elements[0*4+0] *= sx;\n                            self.elements[0*4+1] *= sx;\n                            self.elements[0*4+2] *= sx;\n                            self.elements[0*4+3] *= sx;\n\n                            self.elements[1*4+0] *= sy;\n                            self.elements[1*4+1] *= sy;\n                            self.elements[1*4+2] *= sy;\n                            self.elements[1*4+3] *= sy;\n\n                            self.elements[2*4+0] *= sz;\n                            self.elements[2*4+1] *= sz;\n                            self.elements[2*4+2] *= sz;\n                            self.elements[2*4+3] *= sz;\n\n                            return self;\n                        });\n\n                $loc.translate = new Sk.builtin.func(function(self, tx, ty, tz)\n                        {\n                            self.elements[3*4+0] += self.elements[0*4+0] * tx + self.elements[1*4+0] * ty + self.elements[2*4+0] * tz;\n                            self.elements[3*4+1] += self.elements[0*4+1] * tx + self.elements[1*4+1] * ty + self.elements[2*4+1] * tz;\n                            self.elements[3*4+2] += self.elements[0*4+2] * tx + self.elements[1*4+2] * ty + self.elements[2*4+2] * tz;\n                            self.elements[3*4+3] += self.elements[0*4+3] * tx + self.elements[1*4+3] * ty + self.elements[2*4+3] * tz;\n                            return self;\n                        });\n\n                $loc.rotate = new Sk.builtin.func(function(self, angle, x, y, z)\n                        {\n                            var mag = Math.sqrt(x*x + y*y + z*z);\n                            var sinAngle = Math.sin(angle * Math.PI / 180.0);\n                            var cosAngle = Math.cos(angle * Math.PI / 180.0);\n\n                            if (mag > 0)\n                            {\n                                var xx, yy, zz, xy, yz, zx, xs, ys, zs;\n                                var oneMinusCos;\n                                var rotMat;\n\n                                x /= mag;\n                                y /= mag;\n                                z /= mag;\n\n                                xx = x * x;\n                                yy = y * y;\n                                zz = z * z;\n                                xy = x * y;\n                                yz = y * z;\n                                zx = z * x;\n                                xs = x * sinAngle;\n                                ys = y * sinAngle;\n                                zs = z * sinAngle;\n                                oneMinusCos = 1.0 - cosAngle;\n\n                                rotMat = Sk.misceval.callsim(mod.Mat44);\n\n                                rotMat.elements[0*4+0] = (oneMinusCos * xx) + cosAngle;\n                                rotMat.elements[0*4+1] = (oneMinusCos * xy) - zs;\n                                rotMat.elements[0*4+2] = (oneMinusCos * zx) + ys;\n                                rotMat.elements[0*4+3] = 0.0;\n\n                                rotMat.elements[1*4+0] = (oneMinusCos * xy) + zs;\n                                rotMat.elements[1*4+1] = (oneMinusCos * yy) + cosAngle;\n                                rotMat.elements[1*4+2] = (oneMinusCos * yz) - xs;\n                                rotMat.elements[1*4+3] = 0.0;\n\n                                rotMat.elements[2*4+0] = (oneMinusCos * zx) - ys;\n                                rotMat.elements[2*4+1] = (oneMinusCos * yz) + xs;\n                                rotMat.elements[2*4+2] = (oneMinusCos * zz) + cosAngle;\n                                rotMat.elements[2*4+3] = 0.0;\n\n                                rotMat.elements[3*4+0] = 0.0;\n                                rotMat.elements[3*4+1] = 0.0;\n                                rotMat.elements[3*4+2] = 0.0;\n                                rotMat.elements[3*4+3] = 1.0;\n\n                                rotMat = rotMat.multiply(self);\n                                self.elements = rotMat.elements;\n                            }\n                            return self;\n                        });\n\n                $loc.multiply = new Sk.builtin.func(function(self, right)\n                        {\n                            var tmp = Sk.misceval.callsim(mod.Mat44);\n\n                            for (var i = 0; i < 4; i++)\n                            {\n                                tmp.elements[i*4+0] =\n                                (self.elements[i*4+0] * right.elements[0*4+0]) +\n                                (self.elements[i*4+1] * right.elements[1*4+0]) +\n                                (self.elements[i*4+2] * right.elements[2*4+0]) +\n                                (self.elements[i*4+3] * right.elements[3*4+0]) ;\n\n                                tmp.elements[i*4+1] =\n                                (self.elements[i*4+0] * right.elements[0*4+1]) +\n                                (self.elements[i*4+1] * right.elements[1*4+1]) +\n                                (self.elements[i*4+2] * right.elements[2*4+1]) +\n                                (self.elements[i*4+3] * right.elements[3*4+1]) ;\n\n                                tmp.elements[i*4+2] =\n                                (self.elements[i*4+0] * right.elements[0*4+2]) +\n                                (self.elements[i*4+1] * right.elements[1*4+2]) +\n                                (self.elements[i*4+2] * right.elements[2*4+2]) +\n                                (self.elements[i*4+3] * right.elements[3*4+2]) ;\n\n                                tmp.elements[i*4+3] =\n                                (self.elements[i*4+0] * right.elements[0*4+3]) +\n                                (self.elements[i*4+1] * right.elements[1*4+3]) +\n                                (self.elements[i*4+2] * right.elements[2*4+3]) +\n                                (self.elements[i*4+3] * right.elements[3*4+3]) ;\n                            }\n\n                            self.elements = tmp.elements;\n                            return self;\n                        });\n\n                /* Following gluLookAt implementation is adapted from\n                 * the Mesa 3D Graphics library. http://www.mesa3d.org\n                 */\n                // todo; rewrite this with proper vec/mat ops\n                $loc.lookAt = new Sk.builtin.func(function(self, eyeX, eyeY, eyeZ,\n                                                                 centerX, centerY, centerZ,\n                                                                 upX, upY, upZ)\n                        {\n                            /* Z vector */\n                            var z = [\n                                eyeX - centerX,\n                                eyeY - centerY,\n                                eyeZ - centerZ\n                            ];\n                            var mag = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);\n                            if (mag)\n                            {\n                                z[0] /= mag;\n                                z[1] /= mag;\n                                z[2] /= mag;\n                            }\n\n                            /* Y vector */\n                            var y = [ upX, upY, upZ ];\n\n                            /* X vector = Y cross Z */\n                            var x = [];\n                            x[0] = y[1] * z[2] - y[2] * z[1];\n                            x[1] = -y[0] * z[2] + y[2] * z[0];\n                            x[2] = y[0] * z[1] - y[1] * z[0];\n\n                            /* Recompute Y = Z cross X */\n                            y[0] = z[1] * x[2] - z[2] * x[1];\n                            y[1] = -z[0] * x[2] + z[2] * x[0];\n                            y[2] = z[0] * x[1] - z[1] * x[0];\n\n                            /* mpichler, 19950515 */\n                            /* cross product gives area of parallelogram, which is < 1.0 for\n                            * non-perpendicular unit-length vectors; so normalize x, y here\n                            */\n\n                            mag = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n                            if (mag) {\n                                x[0] /= mag;\n                                x[1] /= mag;\n                                x[2] /= mag;\n                            }\n\n                            mag = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);\n                            if (mag) {\n                                y[0] /= mag;\n                                y[1] /= mag;\n                                y[2] /= mag;\n                            }\n\n                            var lookAt = Sk.misceval.callsim(mod.Mat44);\n                            lookAt.elements[0 * 4 + 0] = x[0];\n                            lookAt.elements[1 * 4 + 0] = x[1];\n                            lookAt.elements[2 * 4 + 0] = x[2];\n                            lookAt.elements[3 * 4 + 0] = 0.;\n                            lookAt.elements[0 * 4 + 1] = y[0];\n                            lookAt.elements[1 * 4 + 1] = y[1];\n                            lookAt.elements[2 * 4 + 1] = y[2];\n                            lookAt.elements[3 * 4 + 1] = 0.;\n                            lookAt.elements[0 * 4 + 2] = z[0];\n                            lookAt.elements[1 * 4 + 2] = z[1];\n                            lookAt.elements[2 * 4 + 2] = z[2];\n                            lookAt.elements[3 * 4 + 2] = 0.;\n                            lookAt.elements[0 * 4 + 3] = 0.;\n                            lookAt.elements[1 * 4 + 3] = 0.;\n                            lookAt.elements[2 * 4 + 3] = 0.;\n                            lookAt.elements[3 * 4 + 3] = 1.;\n\n                            // log(lookAt.elements);\n\n                            lookAt = lookAt.multiply(self);\n                            self.elements = lookAt.elements;\n                            self.translate(-eyeX, -eyeY, -eyeZ);\n\n                            // log(this.elements);\n\n                            return self;\n                        });\n            },\n            'Mat44', []);\n\n    // todo; should probably put this in a math package\n    mod.Mat33 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.callsim($loc.loadIdentity, self);\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0,\n                                         0.0, 0.0, 1.0];\n                    });\n            },\n            'Mat33', []);\n\n    mod.Vec3 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, x, y, z)\n                    {\n                        self.x = x;\n                        self.y = y;\n                        self.z = z;\n                    });\n                $loc.__sub__ = new Sk.builtin.func(function(self, other)\n                    {\n                        return Sk.misceval.callsim(mod.Vec3, self.x - other.x, self.y - other.y, self.z - other.z);\n                    });\n            },\n            'Vec3', []);\n    \n    mod.cross = new Sk.builtin.func(function(v1, v2)\n            {\n                goog.asserts.assert(v1 instanceof mod.Vec3 && v2 instanceof mod.Vec3);\n                return Sk.misceval.callsim(mod.Vec3,\n                    v1.y * v2.z - v1.z * v2.y,\n                    v1.z * v2.x - v1.x * v2.z,\n                    v1.x * v2.y - v1.y * v2.x);\n            });\n\n    return mod;\n};\n", "src/lib/goog/json/__init__.js": "var $builtinmodule = function(name)\n{\n    // todo; is this ok inside the module function when in browser?\n    goog.require('goog.json');\n\n    var mod = {};\n\n    mod.parse = new Sk.builtin.func(function(s)\n            {\n                return Sk.ffi.remapToPy(goog.json.parse(s.v));\n            });\n\n    mod.unsafeParse = new Sk.builtin.func(function(s)\n            {\n                return Sk.ffi.remapToPy(goog.json.unsafeParse(s.v));\n            });\n\n    mod.serialize = new Sk.builtin.func(function(object_)\n            {\n                return new Sk.builtin.str(goog.json.serialize(Sk.ffi.remapToJs(object_)));\n            });\n\n    return mod;\n};\n"}}