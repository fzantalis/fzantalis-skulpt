{"files": {"src/lib/goog/ui/__init__.js": "var $builtinmodule = function(name)\n{\n    goog.require('goog.ui.Component');\n\n    var mod = {};\n\n    mod.Component = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, opt_domHelper)\n                    {\n                        self.v = new goog.ui.Component(Sk.ffi.unwrapo(opt_domHelper));\n                    });\n\n                $loc.render = new Sk.builtin.func(function(self, opt_parentElement)\n                    {\n                        self.v.render(Sk.ffi.unwrapo(opt_parentElement));\n                    });\n            },\n            'Component', []);\n            // todo; derives from EventTarget\n\n    return mod;\n};\n", "src/lib/goog/math/__init__.js": "var $builtinmodule = function(name)\n{\n    goog.require('goog.math');\n\n    // todo; need to convert long -> number\n    //       not super useful since it'll go double in JS and\n    //       then lose precision and generally kind of suck.\n\n    var mod = {};\n\n    mod.randomInt = new Sk.builtin.func(function(a)\n            {\n                return goog.math.randomInt(a);\n            });\n\n    mod.uniformRandom = new Sk.builtin.func(function(a, b)\n            {\n                return goog.math.uniformRandom(a, b);\n            });\n\n    mod.clamp = new Sk.builtin.func(function(value, min, max)\n            {\n                return goog.math.clamp(value, min, max);\n            });\n\n    mod.modulo = new Sk.builtin.func(function(a, b)\n            {\n                return goog.math.modulo(a, b);\n            });\n\n    mod.lerp = new Sk.builtin.func(function(a, b, x)\n            {\n                return goog.math.lerp(a, b, x);\n            });\n\n    // todo; opt_ ?\n    mod.nearlyEquals = new Sk.builtin.func(function(a, b, opt_tolerance)\n            {\n                return goog.math.nearlyEquals(a, b, opt_tolerance);\n            });\n\n    mod.standardAngle = new Sk.builtin.func(function(angleDegrees)\n            {\n                return goog.math.standardAngle(angleDegrees);\n            });\n\n    mod.toRadians = new Sk.builtin.func(function(angleDegrees)\n            {\n                return goog.math.toRadians(angleDegrees);\n            });\n\n    mod.toDegrees = new Sk.builtin.func(function(angleDegrees)\n            {\n                return goog.math.toDegrees(angleDegrees);\n            });\n\n    mod.angleDx = new Sk.builtin.func(function(degrees, radius)\n            {\n                return goog.math.angleDx(degrees, radius);\n            });\n\n    mod.angleDy = new Sk.builtin.func(function(degrees, radius)\n            {\n                return goog.math.angleDy(degrees, radius);\n            });\n\n    mod.angle = new Sk.builtin.func(function(x1, y1, x2, y2)\n            {\n                return goog.math.angle(x1, y1, x2, y2);\n            });\n\n    mod.angleDifference = new Sk.builtin.func(function(startAngle, endAngle)\n            {\n                return goog.math.angleDifference(startAngle, endAngle);\n            });\n\n    mod.sign = new Sk.builtin.func(function(x)\n            {\n                return goog.math.sign(x);\n            });\n\n    // todo; opt_ ?\n    mod.longestCommonSubsequence = new Sk.builtin.func(function(array1, array2, opt_compareFn, opt_collectorFn)\n            {\n                return Sk.ffi.remapToPy(\n                    goog.math.longestCommonSubsequence(\n                        Sk.ffi.remapToJs(array1),\n                        Sk.ffi.remapToJs(array2),\n                        Sk.ffi.callback(opt_compareFn),\n                        Sk.ffi.callback(opt_collectorFn)));\n            });\n\n    mod.sum = new Sk.builtin.func(function()\n            {\n                goog.asserts.fail(\"varargs\");\n            });\n\n    mod.average = new Sk.builtin.func(function()\n            {\n                goog.asserts.fail(\"varargs\");\n            });\n\n    mod.standardDeviation = new Sk.builtin.func(function()\n            {\n                goog.asserts.fail(\"varargs\");\n            });\n\n    mod.isInt = new Sk.builtin.func(function(num)\n            {\n                return goog.math.isInt(num);\n            });\n\n    mod.isFiniteNumber = new Sk.builtin.func(function(num)\n            {\n                return goog.math.isFiniteNumber(num);\n            });\n\n\n    goog.require('goog.math.Coordinate');\n    var coord = function($gbl, $loc)\n    {\n        $loc.__init__ = new Sk.builtin.func(function(self, opt_x, opt_y)\n                {\n                    self.v = new goog.math.Coordinate(opt_x, opt_y);\n                });\n\n        $loc.clone = new Sk.builtin.func(function(self)\n                {\n                    return Sk.ffi.stdwrap(mod.Coordinate, self.v.clone());\n                });\n\n        $loc.toString = new Sk.builtin.func(function(self)\n                {\n                    return new Sk.builtin.str(self.v.toString());\n                });\n        $loc.__repr__ = $loc.toString;\n\n        $loc.equals = new Sk.builtin.func(function(a, b)\n                {\n                    return goog.math.Coordinate.equals(a.v, b.v);\n                });\n\n        $loc.distance = new Sk.builtin.func(function(a, b)\n                {\n                    return goog.math.Coordinate.distance(a.v, b.v);\n                });\n\n        $loc.squaredDistance = new Sk.builtin.func(function(a, b)\n                {\n                    return goog.math.Coordinate.squaredDistance(a.v, b.v);\n                });\n\n        $loc.difference = new Sk.builtin.func(function(a, b)\n                {\n                    return Sk.ffi.stdwrap(mod.Coordinate, goog.math.Coordinate.difference(a.v, b.v));\n                });\n\n        $loc.sum = new Sk.builtin.func(function(a, b)\n                {\n                    return Sk.ffi.stdwrap(mod.Coordinate, goog.math.Coordinate.sum(a.v, b.v));\n                });\n\n\n    };\n    mod.Coordinate = Sk.misceval.buildClass(mod, coord, 'Coordinate', []);\n\n\n    goog.require('goog.math.Vec2');\n    var vec2 = function($gbl, $loc)\n    {\n        $loc.__init__ = new Sk.builtin.func(function(self, opt_x, opt_y)\n                {\n                    self.v = new goog.math.Vec2(opt_x, opt_y);\n                });\n\n        $loc.randomUnit = new Sk.builtin.func(function()\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.randomUnit());\n                });\n\n        $loc.random = new Sk.builtin.func(function()\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.random());\n                });\n\n        $loc.clone = new Sk.builtin.func(function(self)\n                {\n                    return new Sk.ffi.stdwrap(mod.Vec2, self.v.clone());\n                });\n\n        $loc.fromCoordinate = new Sk.builtin.func(function(a)\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.fromCoordinate(a.v));\n                });\n\n        $loc.magnitude = new Sk.builtin.func(function(self)\n                {\n                    return self.v.magnitude();\n                });\n\n        $loc.squaredMagnitude = new Sk.builtin.func(function(self)\n                {\n                    return self.v.squaredMagnitude();\n                });\n\n        $loc.scale = new Sk.builtin.func(function(self, s)\n                {\n                    self.v.scale(s);\n                });\n\n        $loc.invert = new Sk.builtin.func(function(self)\n                {\n                    self.v.invert();\n                });\n\n        $loc.normalize = new Sk.builtin.func(function(self)\n                {\n                    self.v.normalize();\n                });\n\n        $loc.add = new Sk.builtin.func(function(self, b)\n                {\n                    self.v.add(b.v);\n                });\n\n        $loc.subtract = new Sk.builtin.func(function(self, b)\n                {\n                    self.v.subtract(b.v);\n                });\n\n        $loc.equals = new Sk.builtin.func(function(self, b)\n                {\n                    return self.v.equals(b.v);\n                });\n\n        $loc.sum = new Sk.builtin.func(function(a, b)\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.sum(a.v, b.v));\n                });\n\n        $loc.difference = new Sk.builtin.func(function(a, b)\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.difference(a.v, b.v));\n                });\n\n        $loc.dot = new Sk.builtin.func(function(a, b)\n                {\n                    return goog.math.Vec2.dot(a.v, b.v);\n                });\n\n        $loc.lerp = new Sk.builtin.func(function(a, b, x)\n                {\n                    return Sk.ffi.stdwrap(mod.Vec2, goog.math.Vec2.lerp(a.v, b.v, x));\n                });\n    };\n    mod.Vec2 = Sk.misceval.buildClass(mod, vec2, 'Vec2', [ mod.Coordinate ]);\n\n    return mod;\n};\n", "src/lib/webgl/primitives.js": "// most of this file is from 'tdl'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n\n\n    /**\n     * AttribBuffer manages a TypedArray as an array of vectors.\n     *\n     * @param {number} numComponents Number of components per\n     *     vector.\n     * @param {number|!Array.<number>} numElements Number of vectors or the data.\n     * @param {string} opt_type The type of the TypedArray to\n     *     create. Default = 'Float32Array'.\n     * @param {!Array.<number>} opt_data The data for the array.\n     */\n    var AttribBuffer = function(\n            numComponents, numElements, opt_type) {\n        opt_type = opt_type || 'Float32Array';\n        var type = window[opt_type];\n        if (numElements.length) {\n            this.buffer = new type(numElements);\n            numElements = this.buffer.length / numComponents;\n            this.cursor = numElements;\n        } else {\n            this.buffer = new type(numComponents * numElements);\n            this.cursor = 0;\n        }\n        this.numComponents = numComponents;\n        this.numElements = numElements;\n        this.type = opt_type;\n    };\n\n    AttribBuffer.prototype.stride = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.offset = function() {\n        return 0;\n    };\n\n    AttribBuffer.prototype.getElement = function(index) {\n        var offset = index * this.numComponents;\n        var value = [];\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            value.push(this.buffer[offset + ii]);\n        }\n        return value;\n    };\n\n    AttribBuffer.prototype.setElement = function(index, value) {\n        var offset = index * this.numComponents;\n        for (var ii = 0; ii < this.numComponents; ++ii) {\n            this.buffer[offset + ii] = value[ii];\n        }\n    };\n\n    AttribBuffer.prototype.clone = function() {\n        var copy = new AttribBuffer(\n                this.numComponents, this.numElements, this.type);\n        copy.pushArray(this);\n        return copy;\n    }\n\n    AttribBuffer.prototype.push = function(value) {\n        this.setElement(this.cursor++, value);\n    };\n\n    AttribBuffer.prototype.pushArray = function(array) {\n        //  this.buffer.set(array, this.cursor * this.numComponents);\n        //  this.cursor += array.numElements;\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            this.push(array.getElement(ii));\n        }\n    };\n\n    AttribBuffer.prototype.pushArrayWithOffset =\n    function(array, offset) {\n        for (var ii = 0; ii < array.numElements; ++ii) {\n            var elem = array.getElement(ii);\n            for (var jj = 0; jj < offset.length; ++jj) {\n                elem[jj] += offset[jj];\n            }\n            this.push(elem);\n        }\n    };\n\n    /**\n    * Computes the extents\n    * @param {!AttribBuffer} positions The positions\n    * @return {!{min: !tdl.math.Vector3, max:!tdl.math.Vector3}}\n    *     The min and max extents.\n    */\n    AttribBuffer.prototype.computeExtents = function() {\n        var numElements = this.numElements;\n        var numComponents = this.numComponents;\n        var minExtent = this.getElement(0);\n        var maxExtent = this.getElement(0);\n        for (var ii = 1; ii < numElements; ++ii) {\n            var element = this.getElement(ii);\n            for (var jj = 0; jj < numComponents; ++jj) {\n                minExtent[jj] = Math.min(minExtent[jj], element[jj]);\n                maxExtent[jj] = Math.max(maxExtent[jj], element[jj]);\n            }\n        }\n        return {min: minExtent, max: maxExtent};\n    };\n\n\n    /**\n     * Creates the vertices and indices for a cube. The\n     * cube will be created around the origin. (-size / 2, size / 2)\n     *\n     * @param {number} size Width, height and depth of the cube.\n     * @return {!Object.<string, !tdl.primitives.AttribBuffer>} The\n     *         created plane vertices.\n     */\n    mod.createCube = new Sk.builtin.func(function(size)\n            {\n                var CUBE_FACE_INDICES_ = [\n                    [3, 7, 5, 1],\n                    [0, 4, 6, 2],\n                    [6, 7, 3, 2],\n                    [0, 1, 5, 4],\n                    [5, 7, 6, 4],\n                    [2, 3, 1, 0]\n                ];\n\n                var k = size / 2;\n\n                var cornerVertices = [\n                        [-k, -k, -k],\n                        [+k, -k, -k],\n                        [-k, +k, -k],\n                        [+k, +k, -k],\n                        [-k, -k, +k],\n                        [+k, -k, +k],\n                        [-k, +k, +k],\n                        [+k, +k, +k]\n                    ];\n\n                var faceNormals = [\n                        [+1, +0, +0],\n                        [-1, +0, +0],\n                        [+0, +1, +0],\n                        [+0, -1, +0],\n                        [+0, +0, +1],\n                        [+0, +0, -1]\n                    ];\n\n                var uvCoords = [\n                        [0, 0],\n                        [1, 0],\n                        [1, 1],\n                        [0, 1]\n                    ];\n\n                var numVertices = 6 * 4;\n                var positions = new AttribBuffer(3, numVertices);\n                var normals = new AttribBuffer(3, numVertices);\n                var texCoords = new AttribBuffer(2, numVertices);\n                var indices = new AttribBuffer(3, 6 * 2, 'Uint16Array');\n\n                for (var f = 0; f < 6; ++f) {\n                    var faceIndices = CUBE_FACE_INDICES_[f];\n                    for (var v = 0; v < 4; ++v) {\n                        var position = cornerVertices[faceIndices[v]];\n                        var normal = faceNormals[f];\n                        var uv = uvCoords[v];\n\n                        // Each face needs all four vertices because the normals and texture\n                        // coordinates are not all the same.\n                        positions.push(position);\n                        normals.push(normal);\n                        texCoords.push(uv);\n\n                    }\n                    // Two triangles make a square face.\n                    var offset = 4 * f;\n                    indices.push([offset + 0, offset + 1, offset + 2]);\n                    indices.push([offset + 0, offset + 2, offset + 3]);\n                }\n\n                return {\n                        position: positions,\n                        normal: normals,\n                        texCoord: texCoords,\n                        indices: indices\n                };\n            });\n\n    return mod;\n};\n", "src/lib/goog/dom/__init__.js": "var $builtinmodule = function(name)\n{\n    goog.require('goog.dom');\n\n    var mod = {};\n\n    mod.getElement = new Sk.builtin.func(function(element)\n            {\n                // todo; need to wrap this with something. Element is a\n                // browser builtin type though, not a Closure one.\n            \n                // todo; assuming str right now (rather than\n                // string|Element)\n                return goog.dom.getElement(element.v);\n            });\n\n\n    mod.Component = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, opt_domHelper)\n                    {\n                        self.v = new goog.ui.Component(Sk.ffi.unwrapo(opt_domHelper));\n                    });\n\n                $loc.render = new Sk.builtin.func(function(self, opt_parentElement)\n                    {\n                        self.v.render(Sk.ffi.unwrapo(opt_parentElement));\n                    });\n            },\n            'Component', []);\n\n    return mod;\n};\n", "src/lib/webgl/__init__.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; won't work compressed\n    mod.tp$name = \"webgl\";\n\n    //\n    // Setup code taken from 'tdl'. I tried to use more of it, but it's a bit\n    // broken.\n    //\n    var makeFailHTML = function(msg) {\n        return '' +\n            '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' +\n            '<td align=\"center\">' +\n            '<div style=\"display: table-cell; vertical-align: middle;\">' +\n            '<div style=\"\">' + msg + '</div>' +\n            '</div>' +\n            '</td></tr></table>';\n    };\n\n    var GET_A_WEBGL_BROWSER = '' +\n        'This page requires a browser that supports WebGL.<br/>' +\n        '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n\n    var NEED_HARDWARE = '' +\n        \"It doesn't appear your computer can support WebGL.<br/>\" +\n        '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n  \n    var create3DContext = function(canvas) {\n        var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n        var context = null;\n        for (var ii = 0; ii < names.length; ++ii) {\n            try {\n                context = canvas.getContext(names[ii]);\n            } catch(e) {}\n            if (context) {\n                break;\n            }\n        }\n        if (context) {\n            // Disallow selection by default. This keeps the cursor from changing to an\n            // I-beam when the user clicks and drags.  It's easier on the eyes.\n            function returnFalse() {\n                return false;\n            }\n\n            canvas.onselectstart = returnFalse;\n            canvas.onmousedown = returnFalse;\n        }\n        return context;\n    };\n\n    var setupWebGL = function(canvasContainerId, opt_canvas) {\n        var container = document.getElementById(canvasContainerId);\n        var context;\n        if (!opt_canvas) {\n            opt_canvas = container.getElementsByTagName(\"canvas\")[0];\n        }\n        if (!opt_canvas) {\n            // this browser doesn't support the canvas tag at all. Not even 2d.\n            container.innerHTML = makeFailHTML(\n                    GET_A_WEBGL_BROWSER);\n            return;\n        }\n\n        var context = create3DContext(opt_canvas);\n        if (!context) {\n            // TODO(gman): fix to official way to detect that it's the user's machine, not the browser.\n            var browserStrings = navigator.userAgent.match(/(\\w+\\/.*? )/g);\n            var browsers = {};\n            try {\n                for (var b = 0; b < browserStrings.length; ++b) {\n                    var parts = browserStrings[b].match(/(\\w+)/g);\n                    var bb = [];\n                    for (var ii = 1; ii < parts.length; ++ii) {\n                        bb.push(parseInt(parts[ii]));\n                    }\n                    browsers[parts[0]] = bb;\n                }\n            } catch (e) {\n            }\n            if (browsers.Chrome &&\n                    (browsers.Chrome[0] > 7 ||\n                     (browsers.Chrome[0] == 7 && browsers.Chrome[1] > 0) ||\n                     (browsers.Chrome[0] == 7 && browsers.Chrome[1] == 0 && browsers.Chrome[2] >= 521))) {\n                container.innerHTML = makeFailHTML(\n                        NEED_HARDWARE);\n            } else {\n                container.innerHTML = makeFailHTML(\n                        GET_A_WEBGL_BROWSER);\n            }\n        }\n        return context;\n    };\n\n    mod.Context = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, canvasid)\n                    {\n                        var canvas = document.getElementById(canvasid.v);\n                        // NB: purposefully leak this to global because\n                        // everything wants it (esp. for constants it's a pain\n                        // to have to pass it to utility functions)\n                        /*var*/ gl = setupWebGL(canvasid.v, canvas)\n                        if (!gl)\n                            throw \"couldn't get webgl context, unsupported browser?\";\n\n                        self.gl = gl;\n                        // all (?) browsers that have webgl support\n                        // __proto__ too so we cheese out and just rip\n                        // them out of there rather than manually\n                        // enumerating the entire webgl api. it wouldn't\n                        // be too difficult to do it \"properly\", just\n                        // long.\n                        for (var k in gl.__proto__)\n                        {\n                            if (typeof gl.__proto__[k] === \"number\")\n                            {\n                                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str(k), gl.__proto__[k]);\n                            }\n                            else if (typeof gl.__proto__[k] === \"function\")\n                            {\n                                (function(key) {\n                                Sk.abstr.objectSetItem(self['$d'], new Sk.builtin.str(k), new Sk.builtin.func(function()\n                                    {\n                                        var f = gl.__proto__[key];\n                                        // todo; assuming only basic\n                                        // type returns?\n                                        return f.apply(gl, arguments);\n                                    }));\n                                }(k));\n                            }\n                        }\n\n                        // set to cornflower so we know we're init'd at least\n                        gl.clearColor(100/255.0,149/255.0,237/255.0,1)\n                        gl.viewport(0, 0, canvas.width, canvas.height);\n                        gl.clear(gl.COLOR_BUFFER_BIT);\n                        gl.flush();\n                        console.log(\"gl initialized\", gl);\n                    });\n\n                $loc.tp$getattr = Sk.builtin.object.prototype.GenericGetAttr;\n\n                $loc.setDrawFunc = new Sk.builtin.func(function(self, func)\n                        {\n                            var startTime = (new Date()).getTime();\n                            var intervalId = setInterval(function() {\n                                    Sk.misceval.call(func, undefined, self, (new Date()).getTime() - startTime);\n                                    if (goog.global.shutdownGLContext)\n                                    {\n                                        clearInterval(intervalId);\n                                        console.log(\"gl draw function shutting down\");\n                                        return;\n                                    }\n                                }, 1000.0 / 60.0);\n                                \n                        });\n            },\n            'Context', []);\n\n    mod.Shader = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, gl, vertex, fragment)\n                        {\n                            self.gl = gl.gl;\n                            var gl = self.gl;\n                            self.program = gl.createProgram();\n                            var vs = gl.createShader(gl.VERTEX_SHADER);\n                            gl.shaderSource(vs, vertex.v);\n                            gl.compileShader(vs);\n                            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))\n                            {\n                                console.log(gl.getShaderInfoLog(vs));\n                                throw new Sk.builtin.SyntaxError(\"Error compiling vertex shader:\" + gl.getShaderInfoLog(vs));\n                            }\n                            gl.attachShader(self.program, vs);\n                            gl.deleteShader(vs);\n                            \n                            var fs = gl.createShader(gl.FRAGMENT_SHADER);\n                            gl.shaderSource(fs, fragment.v);\n                            gl.compileShader(fs);\n                            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))\n                            {\n                                console.log(gl.getShaderInfoLog(fs));\n                                throw new Sk.builtin.SyntaxError(\"Error compiling fragment shader:\" + gl.getShaderInfoLog(fs));\n                            }\n                            gl.attachShader(self.program, fs);\n                            gl.deleteShader(fs);\n\n                            gl.linkProgram(self.program);\n                            gl.useProgram(self.program);\n\n\n                            //\n                            //\n                            // Some more init code from 'tdl' (slightly\n                            // tweaked)\n                            //\n                            //\n\n                            var endsWith = function(haystack, needle) {\n                                return haystack.substr(haystack.length - needle.length) === needle;\n                            };\n\n                            // Look up attribs.\n                            var attribs = {\n                            };\n                            // Also make a plain table of the locs.\n                            var attribLocs = {\n                            };\n\n                            function createAttribSetter(info, index) {\n                                if (info.size != 1) {\n                                    throw(\"arrays of attribs not handled\");\n                                }\n                                return function(b) {\n                                    gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer());\n                                    gl.enableVertexAttribArray(index);\n                                    gl.vertexAttribPointer(\n                                            index, b.numComponents(), b.type(), false, b.stride(), b.offset());\n                                };\n                            }\n\n                            var numAttribs = gl.getProgramParameter(self.program, gl.ACTIVE_ATTRIBUTES);\n                            for (var ii = 0; ii < numAttribs; ++ii) {\n                                var info = gl.getActiveAttrib(self.program, ii);\n                                name = info.name;\n                                if (endsWith(name, \"[0]\")) {\n                                    name = name.substr(0, name.length - 3);\n                                }\n                                var index = gl.getAttribLocation(self.program, info.name);\n                                attribs[name] = createAttribSetter(info, index);\n                                attribLocs[name] = index\n                            }\n\n                            // Look up uniforms\n                            var numUniforms = gl.getProgramParameter(self.program, gl.ACTIVE_UNIFORMS);\n                            var uniforms = {\n                            };\n\n                            function createUniformSetter(info) {\n                                var loc = gl.getUniformLocation(self.program, info.name);\n                                var type = info.type;\n                                if (info.size > 1 && endsWith(info.name, \"[0]\")) {\n                                    // It's an array.\n                                    if (type == gl.FLOAT)\n                                        return function(v) { gl.uniform1fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC2)\n                                        return function(v) { gl.uniform2fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC3)\n                                        return function(v) { gl.uniform3fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC4)\n                                        return function(v) { gl.uniform4fv(loc, v); };\n                                    if (type == gl.INT)\n                                        return function(v) { gl.uniform1iv(loc, v); };\n                                    if (type == gl.INT_VEC2)\n                                        return function(v) { gl.uniform2iv(loc, v); };\n                                    if (type == gl.INT_VEC3)\n                                        return function(v) { gl.uniform3iv(loc, v); };\n                                    if (type == gl.INT_VEC4)\n                                        return function(v) { gl.uniform4iv(loc, v); };\n                                    if (type == gl.BOOL)\n                                        return function(v) { gl.uniform1iv(loc, v); };\n                                    if (type == gl.BOOL_VEC2)\n                                        return function(v) { gl.uniform2iv(loc, v); };\n                                    if (type == gl.BOOL_VEC3)\n                                        return function(v) { gl.uniform3iv(loc, v); };\n                                    if (type == gl.BOOL_VEC4)\n                                        return function(v) { gl.uniform4iv(loc, v); };\n                                    if (type == gl.FLOAT_MAT2)\n                                        return function(v) { gl.uniformMatrix2fv(loc, false, v); };\n                                    if (type == gl.FLOAT_MAT3)\n                                        return function(v) { gl.uniformMatrix3fv(loc, false, v); };\n                                    if (type == gl.FLOAT_MAT4)\n                                        return function(v) { gl.uniformMatrix4fv(loc, false, v); };\n                                    if (type == gl.SAMPLER_2D)\n                                        return function(v) { gl.uniform1iv(loc, v); };\n                                    if (type == gl.SAMPLER_CUBE_MAP)\n                                        return function(v) { gl.uniform1iv(loc, v); };\n                                    throw (\"unknown type: 0x\" + type.toString(16));\n                                } else {\n                                    if (type == gl.FLOAT)\n                                        return function(v) { gl.uniform1f(loc, v); };\n                                    if (type == gl.FLOAT_VEC2)\n                                        return function(v) { gl.uniform2fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC3)\n                                        return function(v) { gl.uniform3fv(loc, v); };\n                                    if (type == gl.FLOAT_VEC4)\n                                        return function(v) { gl.uniform4fv(loc, v); };\n                                    if (type == gl.INT)\n                                        return function(v) { gl.uniform1i(loc, v); };\n                                    if (type == gl.INT_VEC2)\n                                        return function(v) { gl.uniform2iv(loc, v); };\n                                    if (type == gl.INT_VEC3)\n                                        return function(v) { gl.uniform3iv(loc, v); };\n                                    if (type == gl.INT_VEC4)\n                                        return function(v) { gl.uniform4iv(loc, v); };\n                                    if (type == gl.BOOL)\n                                        return function(v) { gl.uniform1i(loc, v); };\n                                    if (type == gl.BOOL_VEC2)\n                                        return function(v) { gl.uniform2iv(loc, v); };\n                                    if (type == gl.BOOL_VEC3)\n                                        return function(v) { gl.uniform3iv(loc, v); };\n                                    if (type == gl.BOOL_VEC4)\n                                        return function(v) { gl.uniform4iv(loc, v); };\n                                    if (type == gl.FLOAT_MAT2)\n                                        return function(v) { gl.uniformMatrix2fv(loc, false, v); };\n                                    if (type == gl.FLOAT_MAT3)\n                                        return function(v) { gl.uniformMatrix3fv(loc, false, v); };\n                                    if (type == gl.FLOAT_MAT4)\n                                        return function(v) { gl.uniformMatrix4fv(loc, false, v); };\n                                    if (type == gl.SAMPLER_2D)\n                                        return function(v) { gl.uniform1i(loc, v); };\n                                    if (type == gl.SAMPLER_CUBE)\n                                        return function(v) { gl.uniform1i(loc, v); };\n                                    throw (\"unknown type: 0x\" + type.toString(16));\n                                }\n                            }\n\n                            for (var ii = 0; ii < numUniforms; ++ii) {\n                                var info = gl.getActiveUniform(self.program, ii);\n                                name = info.name;\n                                if (endsWith(name, \"[0]\")) {\n                                    name = name.substr(0, name.length - 3);\n                                }\n                                uniforms[name] = createUniformSetter(info);\n                            }\n\n                            self.attrib = attribs;\n                            self.attribLoc = attribLocs;\n                            self.uniform = uniforms;\n                        });\n\n                $loc.setUniform = new Sk.builtin.func(function(self, uniform, value)\n                        {\n                            var func = self.uniform[uniform.v];\n                            if (func)\n                            {\n                                console.log(\"SET UNI:\", uniform.v, value);\n                                func(Sk.ffi.remapToJs(value));\n                            }\n                        });\n\n                $loc.use = new Sk.builtin.func(function(self)\n                        {\n                            self.gl.useProgram(self.program);\n                        });\n            },\n            'Shader', []);\n\n\n    mod.Float32Array = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, data)\n                        {\n                            if (typeof data === \"number\")\n                                self.v = new Float32Array(data);\n                            else\n                                self.v = new Float32Array(Sk.ffi.remapToJs(data));\n                        });\n\n                $loc.__repr__ = new Sk.builtin.func(function(self)\n                    {\n                        var copy = [];\n                        for (var i = 0; i < self.v.length; ++i)\n                            copy.push(self.v[i]);\n                        return new Sk.builtin.str(\"[\"+copy.join(', ')+\"]\");\n                    });\n\n            },\n            'Float32Array', []);\n\n\n    return mod;\n};\n", "src/lib/webgl/matrix4.js": "// more from 'tdl'\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var temp0v3_ = new Float32Array(3);\n    var temp1v3_ = new Float32Array(3);\n    var temp2v3_ = new Float32Array(3);\n\n    var temp0v4_ = new Float32Array(4);\n    var temp1v4_ = new Float32Array(4);\n    var temp2v4_ = new Float32Array(4);\n\n    var temp0m4_ = new Float32Array(16);\n    var temp1m4_ = new Float32Array(16);\n    var temp2m4_ = new Float32Array(16);\n\n    var normalize = function(dst, a) {\n        var n = 0.0;\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            n += a[i] * a[i];\n        n = Math.sqrt(n);\n        if (n > 0.00001) {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = a[i] / n;\n        } else {\n            for (var i = 0; i < aLength; ++i)\n                dst[i] = 0;\n        }\n        return dst;\n    };\n\n    var cross = function(dst, a, b) {\n        dst[0] = a[1] * b[2] - a[2] * b[1];\n        dst[1] = a[2] * b[0] - a[0] * b[2];\n        dst[2] = a[0] * b[1] - a[1] * b[0];\n        return dst;\n    };\n\n    var subVector = function(dst, a, b) {\n        var aLength = a.length;\n        for (var i = 0; i < aLength; ++i)\n            dst[i] = a[i] - b[i];\n        return dst;\n    };\n\n    var dot = function(a, b) {\n        return (a[0] * b[0]) + (a[1] * b[1]) + (a[2] * b[2]);\n    };\n\n    mod.lookAt = new Sk.builtin.func(function(view, eye, target, up)\n            {\n                var t0 = temp0v3_;\n                var t1 = temp1v3_;\n                var t2 = temp2v3_;\n\n                var vz = normalize(t0, subVector(t0, eye.v, target.v));\n                var vx = normalize(t1, cross(t1, up.v, vz));\n                var vy = cross(t2, vz, vx);\n\n                var dst = view.v;\n                dst[ 0] = vx[0];\n                dst[ 1] = vy[0];\n                dst[ 2] = vz[0];\n                dst[ 3] = 0;\n                dst[ 4] = vx[1];\n                dst[ 5] = vy[1];\n                dst[ 6] = vz[1];\n                dst[ 7] = 0;\n                dst[ 8] = vx[2];\n                dst[ 9] = vy[2];\n                dst[10] = vz[2];\n                dst[11] = 0;\n                dst[12] = -dot(vx, eye.v);\n                dst[13] = -dot(vy, eye.v);\n                dst[14] = -dot(vz, eye.v);\n                dst[15] = 1;\n\n                return dst;\n            });\n\n    return mod;\n};\n", "src/builtin/sys.js": "var $builtinmodule = function(name)\n{\n    var sys = {};\n\n    var args = [];\n    var argv = Sk.getSysArgv();\n    for (var i = 0; i < argv.length; ++i)\n        args.push(new Sk.builtin.str(argv[i]));\n    sys.argv = new Sk.builtins['list'](args);\n\n    sys.copyright = Sk.builtin['str'](\"Copyright 2009-2010 Scott Graham.\\nAll Rights Reserved.\\n\");\n\n    sys.modules = Sk.sysmodules;\n\n    sys.path = Sk.realsyspath;\n\n    sys.debug = new Sk.builtin.func(function() {\n        debugger;\n    });\n\n    return sys;\n};\n", "src/lib/goog/__init__.py": "", "src/lib/goog/json/__init__.js": "var $builtinmodule = function(name)\n{\n    // todo; is this ok inside the module function when in browser?\n    goog.require('goog.json');\n\n    var mod = {};\n\n    mod.parse = new Sk.builtin.func(function(s)\n            {\n                return Sk.ffi.remapToPy(goog.json.parse(s.v));\n            });\n\n    mod.unsafeParse = new Sk.builtin.func(function(s)\n            {\n                return Sk.ffi.remapToPy(goog.json.unsafeParse(s.v));\n            });\n\n    mod.serialize = new Sk.builtin.func(function(object_)\n            {\n                return new Sk.builtin.str(goog.json.serialize(Sk.ffi.remapToJs(object_)));\n            });\n\n    return mod;\n};\n", "src/lib/goog/graphics/__init__.js": "var $builtinmodule = function(name)\n{\n    goog.require('goog.graphics');\n\n    var mod = {};\n\n    mod.createGraphics = new Sk.builtin.func(function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper)\n            {\n                return new Sk.ffi.stdwrap(mod.AbstractGraphics, goog.graphics.createGraphics(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper));\n            });\n\n    mod.createSimpleGraphics = new Sk.builtin.func(function(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper)\n            {\n                return new Sk.ffi.stdwrap(mod.AbstractGraphics, goog.graphics.createSimpleGraphics(width, height, opt_coordWidth, opt_coordHeight, opt_domHelper));\n            });\n\n\n    goog.require('goog.graphics.AbstractGraphics');\n\n    // todo; shortcut for this\n    var goog_ui_Component = Sk.importModule('goog.ui').tp$getattr('ui').tp$getattr('Component');\n    mod.AbstractGraphics = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.getCanvasElement = new Sk.builtin.func(function(self)\n                        {\n                            // todo; wrap\n                            return self.v.getCanvasElement();\n                        });\n\n                $loc.drawRect = new Sk.builtin.func(function(self, x, y, width, height, stroke, fill, opt_group)\n                        {\n                            // todo; wrap with RectElement\n                            return self.v.drawRect(x, y, width, height, Sk.ffi.unwrapn(stroke), Sk.ffi.unwrapn(fill), Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.drawImage = new Sk.builtin.func(function(self, x, y, width, height, src, opt_group)\n                        {\n                            // todo; wrap with ImageElement\n                            return self.v.drawImage(x, y, width, height, src.v, Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.drawCircle = new Sk.builtin.func(function(self, cx, cy, r, stroke, fill, opt_group)\n                        {\n                            // todo; wrap with EllipseElement\n                            return self.v.drawCircle(cx, cy, r, Sk.ffi.unwrapn(stroke), Sk.ffi.unwrapn(fill), Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.drawEllipse = new Sk.builtin.func(function(self, cx, cy, rx, ry, stroke, fill, opt_group)\n                        {\n                            // todo; wrap with EllipseElement\n                            return self.v.drawEllipse(cx, cy, rx, ry, Sk.ffi.unwrapn(stroke), Sk.ffi.unwrapn(fill), Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.drawPath = new Sk.builtin.func(function(self, path, stroke, fill, opt_group)\n                        {\n                            // todo; wrap with PathElement\n                            return self.v.drawPath(path.v, Sk.ffi.unwrapn(stroke), Sk.ffi.unwrapn(fill), Sk.ffi.unwrapo(opt_group));\n                        });\n\n                $loc.__repr__ = new Sk.builtin.func(function(self)\n                        {\n                            return new Sk.builtin.str(\"<AbstractGraphics instance>\");\n                        });\n            },\n            'AbstractGraphics', [ goog_ui_Component ]);\n\n    goog.require('goog.graphics.SolidFill');\n    mod.SolidFill = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, color, opt_opacity)\n                    {\n                        self.v = new goog.graphics.SolidFill(color.v, opt_opacity);\n                    });\n\n                $loc.getColor = new Sk.builtin.func(function(self)\n                    {\n                        return new Sk.builtin.str(self.v.getColor());\n                    });\n\n                $loc.getOpacity = new Sk.builtin.func(function(self)\n                    {\n                        return self.v.getOpacity();\n                    });\n            },\n            'SolidFill', []);\n\n    goog.require('goog.graphics.Stroke');\n    mod.Stroke = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, width, color)\n                    {\n                        self.v = new goog.graphics.Stroke(width, color.v);\n                    });\n\n                $loc.getWidth = new Sk.builtin.func(function(self)\n                    {\n                        return Sk.ffi.basicwrap(self.v.getWidth());\n                    });\n\n                $loc.getColor = new Sk.builtin.func(function(self)\n                    {\n                        return self.v.getColor();\n                    });\n            },\n            'Stroke', []);\n\n    goog.require('goog.graphics.Path');\n    mod.Path = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        self.v = new goog.graphics.Path();\n                    });\n\n                $loc.moveTo = new Sk.builtin.func(function(self, x, y)\n                    {\n                        self.v.moveTo(x, y);\n                        return self;\n                    });\n\n                $loc.lineTo = new Sk.builtin.func(function(self, x, y)\n                    {\n                        self.v.lineTo(x, y);\n                        return self;\n                    });\n\n                $loc.close = new Sk.builtin.func(function(self)\n                    {\n                        self.v.close();\n                        return self;\n                    });\n            },\n            'Path', []);\n\n    return mod;\n};\n", "src/lib/webgl/math.js": "var $builtinmodule = function(name)\n{\n    var mod = {};\n\n    // todo; should probably put this in a math package\n    mod.Mat44 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.call($loc.loadIdentity, undefined, self);\n                        self.stack = [];\n                    });\n\n                $loc.push = new Sk.builtin.func(function(self)\n                    {\n                        self.stack.push(self.elements.slice(0));\n                    });\n\n                $loc.pop = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = self.stack.pop();\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0, 0.0,\n                                         0.0, 0.0, 1.0, 0.0,\n                                         0.0, 0.0, 0.0, 1.0];\n                    });\n\n                $loc.transform3 = new Sk.builtin.func(function(self, v)\n                    {\n                        var e = self.elements;\n                        return Sk.misceval.call(mod.Vec3, undefined,\n                            e[0] * v.x + e[4] * v.y + e[8] * v.z,\n                            e[1] * v.x + e[5] * v.y + e[9] * v.z,\n                            e[2] * v.x + e[6] * v.y + e[10] * v.z);\n                    });\n\n                $loc.scale = new Sk.builtin.func(function(self, sx, sy, sz)\n                        {\n                            self.elements[0*4+0] *= sx;\n                            self.elements[0*4+1] *= sx;\n                            self.elements[0*4+2] *= sx;\n                            self.elements[0*4+3] *= sx;\n\n                            self.elements[1*4+0] *= sy;\n                            self.elements[1*4+1] *= sy;\n                            self.elements[1*4+2] *= sy;\n                            self.elements[1*4+3] *= sy;\n\n                            self.elements[2*4+0] *= sz;\n                            self.elements[2*4+1] *= sz;\n                            self.elements[2*4+2] *= sz;\n                            self.elements[2*4+3] *= sz;\n\n                            return self;\n                        });\n\n                $loc.translate = new Sk.builtin.func(function(self, tx, ty, tz)\n                        {\n                            self.elements[3*4+0] += self.elements[0*4+0] * tx + self.elements[1*4+0] * ty + self.elements[2*4+0] * tz;\n                            self.elements[3*4+1] += self.elements[0*4+1] * tx + self.elements[1*4+1] * ty + self.elements[2*4+1] * tz;\n                            self.elements[3*4+2] += self.elements[0*4+2] * tx + self.elements[1*4+2] * ty + self.elements[2*4+2] * tz;\n                            self.elements[3*4+3] += self.elements[0*4+3] * tx + self.elements[1*4+3] * ty + self.elements[2*4+3] * tz;\n                            return self;\n                        });\n\n                $loc.rotate = new Sk.builtin.func(function(self, angle, x, y, z)\n                        {\n                            var mag = Math.sqrt(x*x + y*y + z*z);\n                            var sinAngle = Math.sin(angle * Math.PI / 180.0);\n                            var cosAngle = Math.cos(angle * Math.PI / 180.0);\n\n                            if (mag > 0)\n                            {\n                                var xx, yy, zz, xy, yz, zx, xs, ys, zs;\n                                var oneMinusCos;\n                                var rotMat;\n\n                                x /= mag;\n                                y /= mag;\n                                z /= mag;\n\n                                xx = x * x;\n                                yy = y * y;\n                                zz = z * z;\n                                xy = x * y;\n                                yz = y * z;\n                                zx = z * x;\n                                xs = x * sinAngle;\n                                ys = y * sinAngle;\n                                zs = z * sinAngle;\n                                oneMinusCos = 1.0 - cosAngle;\n\n                                rotMat = Sk.misceval.call(mod.Mat44, undefined);\n\n                                rotMat.elements[0*4+0] = (oneMinusCos * xx) + cosAngle;\n                                rotMat.elements[0*4+1] = (oneMinusCos * xy) - zs;\n                                rotMat.elements[0*4+2] = (oneMinusCos * zx) + ys;\n                                rotMat.elements[0*4+3] = 0.0;\n\n                                rotMat.elements[1*4+0] = (oneMinusCos * xy) + zs;\n                                rotMat.elements[1*4+1] = (oneMinusCos * yy) + cosAngle;\n                                rotMat.elements[1*4+2] = (oneMinusCos * yz) - xs;\n                                rotMat.elements[1*4+3] = 0.0;\n\n                                rotMat.elements[2*4+0] = (oneMinusCos * zx) - ys;\n                                rotMat.elements[2*4+1] = (oneMinusCos * yz) + xs;\n                                rotMat.elements[2*4+2] = (oneMinusCos * zz) + cosAngle;\n                                rotMat.elements[2*4+3] = 0.0;\n\n                                rotMat.elements[3*4+0] = 0.0;\n                                rotMat.elements[3*4+1] = 0.0;\n                                rotMat.elements[3*4+2] = 0.0;\n                                rotMat.elements[3*4+3] = 1.0;\n\n                                rotMat = rotMat.multiply(self);\n                                self.elements = rotMat.elements;\n                            }\n                            return self;\n                        });\n\n                $loc.multiply = new Sk.builtin.func(function(self, right)\n                        {\n                            var tmp = Sk.misceval.call(mod.Mat44, undefined);\n\n                            for (var i = 0; i < 4; i++)\n                            {\n                                tmp.elements[i*4+0] =\n                                (self.elements[i*4+0] * right.elements[0*4+0]) +\n                                (self.elements[i*4+1] * right.elements[1*4+0]) +\n                                (self.elements[i*4+2] * right.elements[2*4+0]) +\n                                (self.elements[i*4+3] * right.elements[3*4+0]) ;\n\n                                tmp.elements[i*4+1] =\n                                (self.elements[i*4+0] * right.elements[0*4+1]) +\n                                (self.elements[i*4+1] * right.elements[1*4+1]) +\n                                (self.elements[i*4+2] * right.elements[2*4+1]) +\n                                (self.elements[i*4+3] * right.elements[3*4+1]) ;\n\n                                tmp.elements[i*4+2] =\n                                (self.elements[i*4+0] * right.elements[0*4+2]) +\n                                (self.elements[i*4+1] * right.elements[1*4+2]) +\n                                (self.elements[i*4+2] * right.elements[2*4+2]) +\n                                (self.elements[i*4+3] * right.elements[3*4+2]) ;\n\n                                tmp.elements[i*4+3] =\n                                (self.elements[i*4+0] * right.elements[0*4+3]) +\n                                (self.elements[i*4+1] * right.elements[1*4+3]) +\n                                (self.elements[i*4+2] * right.elements[2*4+3]) +\n                                (self.elements[i*4+3] * right.elements[3*4+3]) ;\n                            }\n\n                            self.elements = tmp.elements;\n                            return self;\n                        });\n\n                /* Following gluLookAt implementation is adapted from\n                 * the Mesa 3D Graphics library. http://www.mesa3d.org\n                 */\n                // todo; rewrite this with proper vec/mat ops\n                $loc.lookAt = new Sk.builtin.func(function(self, eyeX, eyeY, eyeZ,\n                                                                 centerX, centerY, centerZ,\n                                                                 upX, upY, upZ)\n                        {\n                            /* Z vector */\n                            var z = [\n                                eyeX - centerX,\n                                eyeY - centerY,\n                                eyeZ - centerZ\n                            ];\n                            var mag = Math.sqrt(z[0] * z[0] + z[1] * z[1] + z[2] * z[2]);\n                            if (mag)\n                            {\n                                z[0] /= mag;\n                                z[1] /= mag;\n                                z[2] /= mag;\n                            }\n\n                            /* Y vector */\n                            var y = [ upX, upY, upZ ];\n\n                            /* X vector = Y cross Z */\n                            var x = [];\n                            x[0] = y[1] * z[2] - y[2] * z[1];\n                            x[1] = -y[0] * z[2] + y[2] * z[0];\n                            x[2] = y[0] * z[1] - y[1] * z[0];\n\n                            /* Recompute Y = Z cross X */\n                            y[0] = z[1] * x[2] - z[2] * x[1];\n                            y[1] = -z[0] * x[2] + z[2] * x[0];\n                            y[2] = z[0] * x[1] - z[1] * x[0];\n\n                            /* mpichler, 19950515 */\n                            /* cross product gives area of parallelogram, which is < 1.0 for\n                            * non-perpendicular unit-length vectors; so normalize x, y here\n                            */\n\n                            mag = Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n                            if (mag) {\n                                x[0] /= mag;\n                                x[1] /= mag;\n                                x[2] /= mag;\n                            }\n\n                            mag = Math.sqrt(y[0] * y[0] + y[1] * y[1] + y[2] * y[2]);\n                            if (mag) {\n                                y[0] /= mag;\n                                y[1] /= mag;\n                                y[2] /= mag;\n                            }\n\n                            var lookAt = Sk.misceval.call(mod.Mat44, undefined);\n                            lookAt.elements[0 * 4 + 0] = x[0];\n                            lookAt.elements[1 * 4 + 0] = x[1];\n                            lookAt.elements[2 * 4 + 0] = x[2];\n                            lookAt.elements[3 * 4 + 0] = 0.;\n                            lookAt.elements[0 * 4 + 1] = y[0];\n                            lookAt.elements[1 * 4 + 1] = y[1];\n                            lookAt.elements[2 * 4 + 1] = y[2];\n                            lookAt.elements[3 * 4 + 1] = 0.;\n                            lookAt.elements[0 * 4 + 2] = z[0];\n                            lookAt.elements[1 * 4 + 2] = z[1];\n                            lookAt.elements[2 * 4 + 2] = z[2];\n                            lookAt.elements[3 * 4 + 2] = 0.;\n                            lookAt.elements[0 * 4 + 3] = 0.;\n                            lookAt.elements[1 * 4 + 3] = 0.;\n                            lookAt.elements[2 * 4 + 3] = 0.;\n                            lookAt.elements[3 * 4 + 3] = 1.;\n\n                            // log(lookAt.elements);\n\n                            lookAt = lookAt.multiply(self);\n                            self.elements = lookAt.elements;\n                            self.translate(-eyeX, -eyeY, -eyeZ);\n\n                            // log(this.elements);\n\n                            return self;\n                        });\n            },\n            'Mat44', []);\n\n    // todo; should probably put this in a math package\n    mod.Mat33 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self)\n                    {\n                        Sk.misceval.call($loc.loadIdentity, undefined, self);\n                    });\n\n                $loc.loadIdentity = new Sk.builtin.func(function(self)\n                    {\n                        self.elements = [1.0, 0.0, 0.0,\n                                         0.0, 1.0, 0.0,\n                                         0.0, 0.0, 1.0];\n                    });\n            },\n            'Mat33', []);\n\n    mod.Vec3 = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, x, y, z)\n                    {\n                        self.x = x;\n                        self.y = y;\n                        self.z = z;\n                    });\n                $loc.__sub__ = new Sk.builtin.func(function(self, other)\n                    {\n                        return Sk.misceval.call(mod.Vec3, undefined, self.x - other.x, self.y - other.y, self.z - other.z);\n                    });\n            },\n            'Vec3', []);\n    \n    mod.cross = new Sk.builtin.func(function(v1, v2)\n            {\n                goog.asserts.assert(v1 instanceof mod.Vec3 && v2 instanceof mod.Vec3);\n                return Sk.misceval.call(mod.Vec3, undefined,\n                    v1.y * v2.z - v1.z * v2.y,\n                    v1.z * v2.x - v1.x * v2.z,\n                    v1.x * v2.y - v1.y * v2.x);\n            });\n\n    return mod;\n};\n", "src/builtin/this.py": "s = \"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd = {}\nfor c in (65, 97):\n    for i in range(26):\n        d[chr(i+c)] = chr((i+13) % 26 + c)\n\nprint \"\".join([d.get(c, c) for c in s])\n", "src/lib/webgl/models.js": "// most of this file is from/based on 'tdl'\n\nvar $builtinmodule = function(name)\n{\n    var mod = {};\n\n    var Buffer = function(array, opt_target) {\n        var target = opt_target || gl.ARRAY_BUFFER;\n        var buf = gl.createBuffer();\n        this.target = target;\n        this.buf = buf;\n        this.set(array);\n        this.numComponents_ = array.numComponents;\n        this.numElements_ = array.numElements;\n        this.totalComponents_ = this.numComponents_ * this.numElements_;\n        if (array.buffer instanceof Float32Array) {\n            this.type_ = gl.FLOAT;\n        } else if (array.buffer instanceof Uint8Array) {\n            this.type_ = gl.UNSIGNED_BYTE;\n        } else if (array.buffer instanceof Int8Array) {\n            this.type_ = gl._BYTE;\n        } else if (array.buffer instanceof Uint16Array) {\n            this.type_ = gl.UNSIGNED_SHORT;\n        } else if (array.buffer instanceof Int16Array) {\n            this.type_ = gl.SHORT;\n        } else {\n            throw(\"unhandled type:\" + (typeof array.buffer));\n        }\n    };\n\n    Buffer.prototype.set = function(array) {\n        gl.bindBuffer(this.target, this.buf);\n        gl.bufferData(this.target, array.buffer, gl.STATIC_DRAW);\n    }\n\n    Buffer.prototype.type = function() {\n        return this.type_;\n    };\n\n    Buffer.prototype.numComponents = function() {\n        return this.numComponents_;\n    };\n\n    Buffer.prototype.numElements = function() {\n        return this.numElements_;\n    };\n\n    Buffer.prototype.totalComponents = function() {\n        return this.totalComponents_;\n    };\n\n    Buffer.prototype.buffer = function() {\n        return this.buf;\n    };\n\n    Buffer.prototype.stride = function() {\n        return 0;\n    };\n\n    Buffer.prototype.offset = function() {\n        return 0;\n    };\n\n\n\n    mod.Model = Sk.misceval.buildClass(mod, function($gbl, $loc)\n            {\n                $loc.__init__ = new Sk.builtin.func(function(self, shader, arrays, textures)\n                    {\n                        self.buffers = {};\n                        var setBuffer = function(name, array)\n                        {\n                            var target = (name == 'indices') ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n                            b = self.buffers[name];\n                            if (!b)\n                                b = new Buffer(array, target);\n                            else\n                                b.set(array);\n                            self.buffers[name] = b;\n                        };\n                        for (name in arrays)\n                            setBuffer(name, arrays[name]);\n\n                        var textureUnits = {};\n                        var unit = 0;\n                        for (var texture in textures)\n                        {\n                            textureUnits[texture] = unit++;\n                        }\n\n                        self.mode = gl.TRIANGLES;\n                        self.textures = textures.v;\n                        self.textureUnits = textureUnits;\n                        self.shader = shader;\n                    });\n\n                /**\n                * Sets up the shared parts of drawing this model. Uses the\n                * program, binds the buffers, sets the textures.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.drawPrep = new Sk.builtin.func(function(self, uniforms)\n                    {\n                        var shader = self.shader;\n                        var buffers = self.buffers;\n                        var textures = self.textures;\n\n                        Sk.misceval.call(shader.use, undefined, shader);\n\n                        for (var buffer in buffers) {\n                            var b = buffers[buffer];\n                            if (buffer == 'indices') {\n                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.buffer());\n                            } else {\n                                var attrib = shader.attrib[buffer];\n                                if (attrib) {\n                                    attrib(b);\n                                }\n                            }\n                        }\n\n                        for (var texture in textures) {\n                            var unit = self.textureUnits[texture];\n                            Sk.misceval.call(shader.setUniform, undefined, shader, texture, unit);\n                            textures[texture].bindToUnit(unit);\n                        }\n\n                        for (var uniform in uniforms) {\n                            Sk.misceval.call(shader.setUniform, undefined, shader, uniform, uniforms[uniform]);\n                        }\n                    });\n\n                /**\n                * Draws this model.\n                *\n                * After calling tdl.models.Model.drawPrep you can call this\n                * function multiple times to draw this model.\n                *\n                * @param {!Object.<string, *>} uniforms An object of names to\n                *     values to set on this models uniforms.\n                */\n                $loc.draw = new Sk.builtin.func(function(self, uniforms, opt_textures)\n                    {\n                        var shader = self.shader;\n                        for (uniform in uniforms) {\n                            Sk.misceval.call(shader.setUniform, undefined, shader, uniform, uniforms[uniform]);\n                        }\n\n                        if (opt_textures) {\n                            for (var texture in opt_textures) {\n                                var unit = self.textureUnits[texture];\n                                Sk.misceval.call(shader.setUniform, undefined, shader, texture, unit);\n                                opt_textures[texture].bindToUnit(unit);\n                            }\n                        }\n\n                        var buffers = self.buffers;\n                        gl.drawElements(self.mode, buffers.indices.totalComponents(), gl.UNSIGNED_SHORT, 0);\n                    });\n            },\n            'Model', []);\n\n    return mod;\n};\n"}}